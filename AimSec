--==========AIMLOCK SECTION==========
-- Core Services
local Players            = game:GetService("Players")
local RunService         = game:GetService("RunService")
local UserInputService   = game:GetService("UserInputService")
local Camera             = workspace.CurrentCamera

-- Player References
local LocalPlayer        = Players.LocalPlayer
local Mouse              = LocalPlayer:GetMouse()

-- Drawing Objects
local FOVCircle          = Drawing.new("Circle")
FOVCircle.Thickness      = 2
FOVCircle.NumSides       = 60
FOVCircle.Position       = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
FOVCircle.Radius         = 100
FOVCircle.Color          = Color3.new(1,1,1)
FOVCircle.Transparency   = 1 - 0.5
FOVCircle.Visible        = false

local InfoBox            = Drawing.new("Square")
InfoBox.Size             = Vector2.new(200, 60)
InfoBox.Position         = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
InfoBox.Filled           = true
InfoBox.Visible          = false

local InfoBorder         = Drawing.new("Square")
InfoBorder.Size          = Vector2.new(200, 60)
InfoBorder.Position      = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
InfoBorder.Filled        = false
InfoBorder.Thickness      = 2
InfoBorder.Visible       = false

local StatusText         = Drawing.new("Text")
StatusText.Size          = 20
StatusText.Outline       = true
StatusText.Position      = Vector2.new(Camera.ViewportSize.X/2+5, Camera.ViewportSize.Y/2+5)
StatusText.Visible       = false

local HealthText         = Drawing.new("Text")
HealthText.Size          = 20
HealthText.Outline       = true
HealthText.Position      = Vector2.new(Camera.ViewportSize.X/2+5, Camera.ViewportSize.Y/2+30)
HealthText.Visible       = false

local TargetIndicator    = Drawing.new("Circle")
TargetIndicator.Thickness = 2
TargetIndicator.NumSides = 4
TargetIndicator.Radius   = 5
TargetIndicator.Color     = Color3.new(1,1,1)
TargetIndicator.Transparency = 1 - 0.5
TargetIndicator.Visible  = false

-- State Variables
local CurrentTarget      = nil
local CurrentTargetPart  = nil
local AimlockConnection  = nil
local MouseMoveConnection= nil
local LastShotTime       = 0
local AutoShootCooldown  = 0.02

local STICKY_RANGE       = 15
local FOV_OFFSET_Y       = 57
local INDICATOR_OFFSET_Y = 57

-- Body Part Definitions (R6 & R15)
local BodyPartDefinitions = {
    Head  = {"Head"},
    Torso = {"HumanoidRootPart"},
    Legs  = {"Left Leg","LeftUpperLeg"}
}
local TargetPartOptions = {"Head","Torso","Legs"}

-- Utility Functions
local function FixTransparency(value)
    return 1 - value
end

local function HasForceField(character)
    if not character then return false end
    return character:FindFirstChildWhichIsA("ForceField") ~= nil
end

local function IsVisible(player, part)
    if not player or not player.Character or not part then return false end
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {LocalPlayer.Character}
    local origin = Camera.CFrame.Position
    local dir    = part.Position - origin
    local hit    = workspace:Raycast(origin, dir, params)
    return not (hit and not hit.Instance:IsDescendantOf(player.Character))
end

local function GetBestTargetPart(player, selectedParts)
    if not player or not player.Character then return nil end
    local valid = {}
    local wallCheck = library.flags["WallCheck"]
    for _, partType in ipairs(selectedParts) do
        local names = BodyPartDefinitions[partType]
        if names then
            for _, name in ipairs(names) do
                local part = player.Character:FindFirstChild(name)
                if part and part:IsA("BasePart") then
                    if not wallCheck or IsVisible(player, part) then
                        table.insert(valid, part)
                    end
                end
            end
        end
    end
    
    if #valid == 0 then return nil end
    
    if #selectedParts > 1 then
        local randomIndex = math.random(1, #valid)
        return valid[randomIndex]
    else
        local closest, minDist = nil, math.huge
        local refPoint
        if library.flags["AimMethod"] == "Camera" then
            refPoint = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
        else
            refPoint = Vector2.new(Mouse.X, Mouse.Y + FOV_OFFSET_Y)
        end

        for _, part in ipairs(valid) do
            local sp = Camera:WorldToScreenPoint(part.Position)
            if sp.Z > 0 then
                local screenPos = Vector2.new(sp.X, sp.Y)
                local dist = (screenPos - refPoint).Magnitude
                if dist < minDist then
                    closest, minDist = part, dist
                end
            end
        end
        return closest
    end
end

local function ApplyPrediction(part)
    local mode = library.flags["PredictionMode"]
    if mode == "Off" then return part.Position end
    local vel = part.Velocity
    if mode == "Manual" then
        return part.Position + vel * (library.flags["ManualPrediction"] or 0)
    elseif mode == "Auto" then
        local dist = (Camera.CFrame.Position - part.Position).Magnitude
        return part.Position + vel * (dist / 200)
    end
    return part.Position
end

local function CalculateMove(dx, dy)
    local smooth = library.flags["Smoothness"] or 0
    local stickyAim = library.flags["StickyAim"] or false
    
    if stickyAim then
        local dist = math.sqrt(dx*dx + dy*dy)
        if dist < STICKY_RANGE then
            local slowFactor = dist / STICKY_RANGE
            dx = dx * (slowFactor * 0.5)
            dy = dy * (slowFactor * 0.5)
        end
    end
    
    dx = dx * (1 - smooth)
    dy = dy * (1 - smooth)
    
    return dx, dy
end

local function UpdateFOVPosition()
    if library.flags["AimMethod"] == "Camera" then
        FOVCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    else
        FOVCircle.Position = Vector2.new(Mouse.X, Mouse.Y + FOV_OFFSET_Y)
    end
end

local function UpdateInfoUIVisibility()
    if not library.flags["ShowInfoUI"] or not CurrentTarget then
        InfoBox.Visible = false
        InfoBorder.Visible = false
        StatusText.Visible = false
        HealthText.Visible = false
        TargetIndicator.Visible = false
        return
    end

    InfoBox.Visible   = false
    InfoBorder.Visible= false
    StatusText.Visible= false

    StatusText.Text = "Target: " .. CurrentTarget.Name ..
        (CurrentTargetPart and " ("..CurrentTargetPart.Name..")" or "")

    local humanoid = CurrentTarget.Character and CurrentTarget.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        HealthText.Visible = false
        HealthText.Text    = "Health: " .. math.floor(humanoid.Health)
        if library.flags["DynamicHealthColor"] then
            local pct = humanoid.Health / humanoid.MaxHealth
            HealthText.Color = Color3.fromRGB(255*(1-pct),255*pct,0)
        else
            HealthText.Color       = library.flags["HealthTextColor"] or Color3.new(0,1,0)
            HealthText.Transparency= FixTransparency(library.flags["HealthTextTrans"] or 0)
        end
    else
        HealthText.Visible = false
    end
end

local function SetupFOVTracking()
    if MouseMoveConnection then MouseMoveConnection:Disconnect() end
    
    if library.flags["AimMethod"] == "Mouse" then
        MouseMoveConnection = UserInputService.InputChanged:Connect(function(i)
            if i.UserInputType == Enum.UserInputType.MouseMovement then
                FOVCircle.Position = Vector2.new(Mouse.X, Mouse.Y + FOV_OFFSET_Y)
            end
        end)
    end
end

local function Cleanup()
    if AimlockConnection then AimlockConnection:Disconnect() end
    if MouseMoveConnection then MouseMoveConnection:Disconnect() end
    AimlockConnection, MouseMoveConnection = nil, nil
end

-- Create target display labels (add these to UI section)
_G.CROW.targetName = nil
_G.CROW.targetDisplay = nil
_G.CROW.targetHealth = nil
_G.CROW.targetDistance = nil
_G.CROW.targetTool = nil

local function UpdateTargetIndicator(target, targetPart)
    if not target or not target.Character then
        if _G.CROW.targetName then _G.CROW.targetName:SetValue('nil') end
        if _G.CROW.targetDisplay then _G.CROW.targetDisplay:SetValue('nil') end
        if _G.CROW.targetHealth then _G.CROW.targetHealth:SetValue('0') end
        if _G.CROW.targetDistance then _G.CROW.targetDistance:SetValue('0m') end
        if _G.CROW.targetTool then _G.CROW.targetTool:SetValue('nil') end
        return
    end
    
    if _G.CROW.targetName then _G.CROW.targetName:SetValue(target.Name) end
    local displayName = target.DisplayName or target.Name
    if _G.CROW.targetDisplay then _G.CROW.targetDisplay:SetValue(displayName) end
    
    local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        local healthText = math.floor(humanoid.Health) .. "/" .. math.floor(humanoid.MaxHealth)
        if _G.CROW.targetHealth then _G.CROW.targetHealth:SetValue(healthText) end
    else
        if _G.CROW.targetHealth then _G.CROW.targetHealth:SetValue('0/0') end
    end
    
    local localCharacter = LocalPlayer.Character
    if localCharacter and localCharacter:FindFirstChild("HumanoidRootPart") and target.Character:FindFirstChild("HumanoidRootPart") then
        local distance = (localCharacter.HumanoidRootPart.Position - target.Character.HumanoidRootPart.Position).Magnitude
        if _G.CROW.targetDistance then _G.CROW.targetDistance:SetValue(math.floor(distance) .. 'm') end
    else
        if _G.CROW.targetDistance then _G.CROW.targetDistance:SetValue('0m') end
    end
    
    local tool = target.Character:FindFirstChildOfClass("Tool")
    if tool then
        if _G.CROW.targetTool then _G.CROW.targetTool:SetValue(tool.Name) end
    else
        if _G.CROW.targetTool then _G.CROW.targetTool:SetValue('nil') end
    end
end

local function StartAimlock()
    Cleanup()
    UpdateFOVPosition()
    SetupFOVTracking()
    math.randomseed(tick())

    AimlockConnection = RunService.RenderStepped:Connect(function()
        if not library.flags["AimlockEnabled"] then
            InfoBox.Visible = false
            InfoBorder.Visible = false
            StatusText.Visible = false
            HealthText.Visible = false
            TargetIndicator.Visible = false
            UpdateTargetIndicator(nil, nil)
            return
        end

        local teamCheck       = library.flags["TeamCheck"]
        local wallCheck       = library.flags["WallCheck"]
        local forceFieldCheck = library.flags["ForceFieldCheck"]
        local aimMethod       = library.flags["AimMethod"]
        local partsList       = library.flags["TargetParts"] or {"Head"}
        local fovSize         = library.flags["FOVSize"] or 100
        local autoShoot       = library.flags["AutoShoot"] or false

        FOVCircle.Radius  = fovSize
        FOVCircle.Visible = true

        if CurrentTarget then
            local char     = CurrentTarget.Character
            local humanoid = char and char:FindFirstChildOfClass("Humanoid")
            if not humanoid or humanoid.Health <= 0
            or (forceFieldCheck and HasForceField(char))
            or (wallCheck and CurrentTargetPart and not IsVisible(CurrentTarget, CurrentTargetPart)) then
                CurrentTarget, CurrentTargetPart = nil, nil
                UpdateInfoUIVisibility()
                TargetIndicator.Visible = false
                UpdateTargetIndicator(nil, nil)
            end
        end

        if not CurrentTarget then
            local closest = fovSize
            for _, player in ipairs(Players:GetPlayers()) do
                if player == LocalPlayer then continue end
                local char     = player.Character
                local humanoid = char and char:FindFirstChildOfClass("Humanoid")
                if not humanoid or humanoid.Health <= 0 then continue end
                if teamCheck and player.Team == LocalPlayer.Team then continue end
                if forceFieldCheck and HasForceField(char) then continue end

                local part = GetBestTargetPart(player, partsList)
                if not part then continue end
                if wallCheck and not IsVisible(player, part) then continue end

                local sp = Camera:WorldToScreenPoint(part.Position)
                if sp.Z <= 0 then continue end

                local screenPos = Vector2.new(sp.X, sp.Y)
                local center
                if aimMethod == "Camera" then
                    center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
                else
                    center = Vector2.new(Mouse.X, Mouse.Y + FOV_OFFSET_Y)
                end
                local dist = (screenPos - center).Magnitude

                if dist < closest then
                    CurrentTarget, CurrentTargetPart = player, part
                    closest = dist
                end
            end
            UpdateInfoUIVisibility()
            UpdateTargetIndicator(CurrentTarget, CurrentTargetPart)
        end

        if CurrentTarget and CurrentTargetPart then
            UpdateInfoUIVisibility()
            UpdateTargetIndicator(CurrentTarget, CurrentTargetPart)
            
            local targetPos = ApplyPrediction(CurrentTargetPart)

            if aimMethod == "Camera" then
                local goal = CFrame.new(Camera.CFrame.Position, targetPos)
                local smooth = library.flags["Smoothness"] or 0
                Camera.CFrame = Camera.CFrame:Lerp(goal, 1 - smooth)
            else
                local sp = Camera:WorldToScreenPoint(targetPos)
                if sp.Z > 0 then
                    local dx, dy = sp.X - Mouse.X, sp.Y - Mouse.Y
                    local mx, my = CalculateMove(dx, dy)
                    if mx ~= 0 or my ~= 0 then
                        mousemoverel(mx, my)
                    end
                end
            end

            local sp2 = Camera:WorldToScreenPoint(targetPos)
            if sp2.Z > 0 then
                TargetIndicator.Position = Vector2.new(sp2.X, sp2.Y + INDICATOR_OFFSET_Y)
                TargetIndicator.Visible = true
                
                if autoShoot and tick() - LastShotTime >= AutoShootCooldown then
                    mouse1press()
                    wait()
                    mouse1release()
                    LastShotTime = tick()
                end
            else
                TargetIndicator.Visible = false
            end
        end
    end)
end

local function StopAimlock()
    Cleanup()
    FOVCircle.Visible = false
    InfoBox.Visible = false
    InfoBorder.Visible = false
    StatusText.Visible = false
    HealthText.Visible = false
    TargetIndicator.Visible = false
    CurrentTarget, CurrentTargetPart = nil, nil
    UpdateTargetIndicator(nil, nil)
end

-- UI Section
local secaim = _G.Aimlock:AddSection("Aim Lock", 1)

secaim:AddSeparator({ text = "Main" })

local aimlockToggle = secaim:AddToggle({
    text    = "Key Aim Lock",
    state   = false,
    flag    = "AimlockEnabled",
    tooltip = "Toggle the aim lock",
    callback= function(on)
        if on then StartAimlock() else StopAimlock() end
    end
})
:AddBind({
    text     = "Toggle Aim Lock",
    mode     = "toggle",
    bind     = "NONE",
    flag     = "ToggleKey_1",
    callback = function(on)
        if on then StartAimlock() else StopAimlock() end
    end
})

-- Autoshoot Toggle
secaim:AddToggle({
    text    = "Auto Shoot",
    state   = false,
    flag    = "AutoShoot",
    tooltip = "Automatically shoot when targeting",
    callback= function(on)
        if not on then
            mouse1release()
        end
    end
})

secaim:AddToggle({
    text    = "Team Check",
    state   = false,
    flag    = "TeamCheck",
    tooltip = "Don't target teammates",
    callback= function() CurrentTarget, CurrentTargetPart = nil, nil end
})

secaim:AddToggle({
    text    = "Wall Check",
    state   = false,
    flag    = "WallCheck",
    tooltip = "Don't target through walls",
    callback= function() CurrentTarget, CurrentTargetPart = nil, nil end
})

secaim:AddToggle({
    text    = "ForceField Check",
    state   = false,
    flag    = "ForceFieldCheck",
    tooltip = "Don't target invulnerable players",
    callback= function() CurrentTarget, CurrentTargetPart = nil, nil end
})

secaim:AddToggle({
    text    = "Sticky Aim",
    state   = false,
    flag    = "StickyAim",
    tooltip = "Makes your aim stick to targets"
})

secaim:AddList({
    text     = "Aim Lock Method",
    selected = "Camera",
    values   = {"Camera","Mouse"},
    flag     = "AimMethod",
    tooltip  = "Choose aim method",
    callback = function()
        UpdateFOVPosition()
        SetupFOVTracking()
        CurrentTarget, CurrentTargetPart = nil, nil
    end
})

secaim:AddList({
    text     = "Target Body Parts",
    selected = {"Head"},
    multi    = true,
    values   = TargetPartOptions,
    flag     = "TargetParts",
    tooltip  = "Which body parts to aim at",
    callback = function() CurrentTarget, CurrentTargetPart = nil, nil end
})

secaim:AddSeparator({ text = "Misc" })

secaim:AddSlider({
    text      = "Mouse Smoothness",
    min       = 0,
    max       = 1.0,
    increment = 0.05,
    default   = 0,
    flag      = "Smoothness",
    tooltip   = "Higher = smoother"
})

secaim:AddSlider({
    text      = "FOV Size",
    min       = 50,
    max       = 500,
    increment = 1,
    default   = 100,
    suffix    = "px",
    flag      = "FOVSize",
    tooltip   = "Aim FOV radius",
    callback  = function(v)
        FOVCircle.Radius = v
        CurrentTarget, CurrentTargetPart = nil, nil
    end
})

secaim:AddSeparator({ text = "Prediction" })

secaim:AddList({
    text     = "Prediction Mode",
    selected = "Off",
    values   = {"Off","Manual","Auto"},
    flag     = "PredictionMode",
    tooltip  = "Aim prediction"
})

secaim:AddSlider({
    text      = "Manual Prediction",
    min       = 0,
    max       = 0.5,
    increment = 0.01,
    default   = 0,
    flag      = "ManualPrediction",
    tooltip   = "Manual prediction strength"
})

local secedit = _G.Aimlock:AddSection("Customize", 1)

secedit:AddSeparator({ text = "Colors" })
secedit:AddColor({
    text     = "FOV Circle Color",
    color    = Color3.new(1,1,1),
    trans    = 0.5,
    flag     = "FOVColor",
    tooltip  = "Circle color/transparency",
    callback = function(c,t)
        FOVCircle.Color        = c
        FOVCircle.Transparency = FixTransparency(t)
    end
})
secedit:AddColor({
    text     = "Indicator Color",
    color    = Color3.new(1,1,1),
    trans    = 0.5,
    flag     = "IndicatorColor",
    tooltip  = "Indicator color/transparency",
    callback = function(c,t)
        TargetIndicator.Color        = c
        TargetIndicator.Transparency = FixTransparency(t)
    end
})

-- ===================== SILENT AIM SECTION =====================
local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

local GetPlayers = Players.GetPlayers
local WorldToScreen = Camera.WorldToScreenPoint
local WorldToViewportPoint = Camera.WorldToViewportPoint
local GetPartsObscuringTarget = Camera.GetPartsObscuringTarget
local FindFirstChild = game.FindFirstChild
local RenderStepped = RunService.RenderStepped
local GetMouseLocation = UserInputService.GetMouseLocation

local resume = coroutine.resume 
local create = coroutine.create

-- Performance optimization: Cache mouse position
local CachedMousePosition = Vector2.new(0, 0)
local LastMouseUpdate = 0
local MOUSE_UPDATE_INTERVAL = 0.016 -- ~60 FPS

-- Performance optimization: Cache closest player
local CachedClosestPlayer = nil
local LastPlayerUpdate = 0
local PLAYER_UPDATE_INTERVAL = 0.033 -- ~30 FPS

-- Drawing Objects
local fov_circle = Drawing.new("Circle")
fov_circle.Thickness = 1
fov_circle.NumSides = 100
fov_circle.Radius = 50
fov_circle.Filled = false
fov_circle.Visible = false
fov_circle.ZIndex = 999
fov_circle.Transparency = 1
fov_circle.Color = Color3.fromRGB(54, 57, 241)

local SilentTargetIndicator = Drawing.new("Circle")
SilentTargetIndicator.Thickness = 2
SilentTargetIndicator.NumSides = 4
SilentTargetIndicator.Radius = 5
SilentTargetIndicator.Color = Color3.new(1,1,1)
SilentTargetIndicator.Transparency = 0.5
SilentTargetIndicator.Visible = false

-- Expected Arguments for hooking - EXPANDED TO INCLUDE MORE METHODS
local ExpectedArguments = {
    FindPartOnRayWithIgnoreList = {
        ArgCountRequired = 3,
        Args = {
            "Instance", "Ray", "table", "boolean", "boolean"
        }
    },
    FindPartOnRayWithWhitelist = {
        ArgCountRequired = 3,
        Args = {
            "Instance", "Ray", "table", "boolean"
        }
    },
    FindPartOnRay = {
        ArgCountRequired = 2,
        Args = {
            "Instance", "Ray", "Instance", "boolean", "boolean"
        }
    },
    Raycast = {
        ArgCountRequired = 3,
        Args = {
            "Instance", "Vector3", "Vector3", "RaycastParams"
        }
    }
}

-- Target parts mapping for multi-selection
local TARGET_PARTS = {
    Head = {"Head"},
    Torso = {"HumanoidRootPart"},
    Legs = {"Left Leg", "LeftUpperLeg"}
}

-- Utility Functions
-- Utility Functions
function CalculateChance(Percentage)
    Percentage = math.floor(Percentage)
    local chance = math.floor(Random.new().NextNumber(Random.new(), 0, 1) * 100) / 100
    return chance <= Percentage / 100
end

local function getPositionOnScreen(Vector)
    local Vec3, OnScreen = WorldToScreen(Camera, Vector)
    return Vector2.new(Vec3.X, Vec3.Y), OnScreen
end

local function ValidateArguments(Args, RayMethod)
    local Matches = 0
    if #Args < RayMethod.ArgCountRequired then
        return false
    end
    for Pos, Argument in next, Args do
        if typeof(Argument) == RayMethod.Args[Pos] then
            Matches = Matches + 1
        end
    end
    return Matches >= RayMethod.ArgCountRequired
end

local function getDirection(Origin, Position)
    return (Position - Origin).Unit * 1000
end

-- Optimized mouse position function with caching
local function getMousePosition()
    local currentTime = tick()
    if currentTime - LastMouseUpdate > MOUSE_UPDATE_INTERVAL then
        CachedMousePosition = GetMouseLocation(UserInputService)
        LastMouseUpdate = currentTime
    end
    return CachedMousePosition
end

local function IsPlayerVisible(Player)
    local PlayerCharacter = Player.Character
    local LocalPlayerCharacter = LocalPlayer.Character
    
    if not (PlayerCharacter or LocalPlayerCharacter) then return end 
    
    local PlayerRoot = FindFirstChild(PlayerCharacter, "Head") or FindFirstChild(PlayerCharacter, "HumanoidRootPart")
    
    if not PlayerRoot then return end 
    
    local CastPoints, IgnoreList = {PlayerRoot.Position, LocalPlayerCharacter, PlayerCharacter}, {LocalPlayerCharacter, PlayerCharacter}
    local ObscuringObjects = #GetPartsObscuringTarget(Camera, CastPoints, IgnoreList)
    
    return ((ObscuringObjects == 0 and true) or (ObscuringObjects > 0 and false))
end

-- Function to get selected target parts
local function getSelectedTargetParts()
    local selectedParts = {}
    local selectedBodyParts = library.flags["SilentTargetParts"] or {"Head"}
    
    -- Add parts based on selection
    for _, bodyPart in ipairs(selectedBodyParts) do
        if TARGET_PARTS[bodyPart] then
            for _, part in ipairs(TARGET_PARTS[bodyPart]) do
                table.insert(selectedParts, part)
            end
        end
    end
    
    -- If no parts selected, default to Head
    if #selectedParts == 0 then
        selectedParts = TARGET_PARTS.Head
    end
    
    return selectedParts
end

-- Function to get random target part from character
local function getTargetPart(Character)
    local selectedParts = getSelectedTargetParts()
    
    -- Try to find available parts from selected ones
    local availableParts = {}
    for _, partName in ipairs(selectedParts) do
        local part = FindFirstChild(Character, partName)
        if part then
            table.insert(availableParts, part)
        end
    end
    
    -- Return random available part or fallback to HumanoidRootPart
    if #availableParts > 0 then
        return availableParts[math.random(1, #availableParts)]
    else
        return FindFirstChild(Character, "HumanoidRootPart")
    end
end

-- Optimized closest player function with caching
local function getClosestPlayer()
    local currentTime = tick()
    
    -- Use cached result if within update interval
    if currentTime - LastPlayerUpdate < PLAYER_UPDATE_INTERVAL and CachedClosestPlayer then
        return CachedClosestPlayer
    end
    
    local Closest
    local DistanceToMouse
    local mousePos = getMousePosition()
    
    for _, Player in next, GetPlayers(Players) do
        if Player == LocalPlayer then continue end
        if library.flags["SilentTeamCheck"] and Player.Team == LocalPlayer.Team then continue end

        local Character = Player.Character
        if not Character then continue end
        
        if library.flags["SilentVisibleCheck"] and not IsPlayerVisible(Player) then continue end

        local HumanoidRootPart = FindFirstChild(Character, "HumanoidRootPart")
        local Humanoid = FindFirstChild(Character, "Humanoid")
        if not HumanoidRootPart or not Humanoid or Humanoid and Humanoid.Health <= 0 then continue end

        local ScreenPosition, OnScreen = getPositionOnScreen(HumanoidRootPart.Position)
        if not OnScreen then continue end

        local Distance = (mousePos - ScreenPosition).Magnitude
        if Distance <= (DistanceToMouse or library.flags["SilentFOVSize"] or 50) then
            Closest = getTargetPart(Character)
            DistanceToMouse = Distance
        end
    end
    
    -- Update cache
    CachedClosestPlayer = Closest
    LastPlayerUpdate = currentTime
    
    return Closest
end

-- Function to update FOV visibility
local function updateFOVVisibility()
    fov_circle.Visible = library.flags["SilentAimEnabled"]
end

-- UI Creation - Add to existing Aimlock tab
local SilentAimSection = _G.Aimlock:AddSection("Silent Aim", 2)

SilentAimSection:AddSeparator({ text = "Main" })

SilentAimSection:AddToggle({
    text = "Enabled",
    state = false,
    flag = "SilentAimEnabled",
    callback = function(state)
        updateFOVVisibility()
        if library.flags["SilentShowIndicator"] then
            SilentTargetIndicator.Visible = state
        end
        -- Clear cache when toggling
        CachedClosestPlayer = nil
    end
}):AddBind({
    text = "Toggle Silent Aim",
    mode = "toggle",
    bind = "NONE",
    flag = "SilentAimToggleKey",
    callback = function(state)
        updateFOVVisibility()
        if library.flags["SilentShowIndicator"] then
            SilentTargetIndicator.Visible = state
        end
        -- Clear cache when toggling
        CachedClosestPlayer = nil
    end
})

SilentAimSection:AddToggle({
    text = "Team Check",
    state = false,
    flag = "SilentTeamCheck",
    callback = function()
        CachedClosestPlayer = nil -- Clear cache when settings change
    end
})

SilentAimSection:AddToggle({
    text = "Visible Check",
    state = false,
    flag = "SilentVisibleCheck",
    callback = function()
        CachedClosestPlayer = nil -- Clear cache when settings change
    end
})

-- FIXED: Added proper line break and simplified target selection
SilentAimSection:AddList({
    text = "Target Parts",
    selected = "Head",
    multi = true,
    values = {"Head", "Torso", "Legs"},
    flag = "SilentTargetParts",
    callback = function()
        CachedClosestPlayer = nil
    end
})

-- UPDATED: All available methods
SilentAimSection:AddList({
    text = "Silent Aim Method",
    selected = "Raycast",
    values = {
        "Raycast",
        "FindPartOnRayWithIgnoreList",
        "FindPartOnRayWithWhitelist",
        "FindPartOnRay",
        "All Methods"
    },
    flag = "SilentMethod"
})

SilentAimSection:AddSlider({
    text = "Hit Chance",
    min = 0,
    max = 100,
    increment = 1,
    default = 100,
    suffix = "%",
    flag = "SilentHitChance"
})

-- Customize Section for Silent Aim
local SilentCustomizeSection = _G.Aimlock:AddSection("Silent Aim Customize", 2)

SilentCustomizeSection:AddSeparator({ text = "Field Of View" })

SilentCustomizeSection:AddSlider({
    text = "FOV Size",
    min = 0,
    max = 360,
    increment = 1,
    default = 50,
    suffix = "px",
    flag = "SilentFOVSize",
    callback = function(value)
        fov_circle.Radius = value
        CachedClosestPlayer = nil -- Clear cache when FOV changes
    end
})

SilentCustomizeSection:AddColor({
    text = "FOV Circle Color",
    color = Color3.fromRGB(54, 57, 241),
    trans = 0,
    flag = "SilentFOVColor",
    callback = function(color, trans)
        fov_circle.Color = color
        fov_circle.Transparency = 1 - trans
    end
})

SilentCustomizeSection:AddSeparator({ text = "Target Indicator" })

SilentCustomizeSection:AddToggle({
    text = "Show Target Indicator",
    state = false,
    flag = "SilentShowIndicator",
    callback = function(state)
        SilentTargetIndicator.Visible = state and library.flags["SilentAimEnabled"]
    end
})

SilentCustomizeSection:AddColor({
    text = "Indicator Color",
    color = Color3.new(1,1,1),
    trans = 0.5,
    flag = "SilentIndicatorColor",
    callback = function(color, trans)
        SilentTargetIndicator.Color = color
        SilentTargetIndicator.Transparency = 1 - trans
    end
})

-- Optimized Render Loop with reduced frequency
local lastRenderTime = 0
local RENDER_INTERVAL = 0.016 -- ~60 FPS cap

resume(create(function()
    RenderStepped:Connect(function()
        local currentTime = tick()
        
        -- Limit render frequency
        if currentTime - lastRenderTime < RENDER_INTERVAL then
            return
        end
        lastRenderTime = currentTime
        
        if library.flags["SilentShowIndicator"] and library.flags["SilentAimEnabled"] then
            local target = getClosestPlayer()
            if target then 
                local Root = target.Parent.PrimaryPart or target
                local RootToViewportPoint, IsOnScreen = WorldToViewportPoint(Camera, Root.Position)
                
                SilentTargetIndicator.Visible = IsOnScreen
                SilentTargetIndicator.Position = Vector2.new(RootToViewportPoint.X, RootToViewportPoint.Y)
            else 
                SilentTargetIndicator.Visible = false 
            end
        else
            SilentTargetIndicator.Visible = false
        end
        
        -- Updated FOV circle logic - always show when Silent Aim is enabled
        if library.flags["SilentAimEnabled"] then 
            fov_circle.Visible = true
            fov_circle.Position = getMousePosition()
        else
            fov_circle.Visible = false
        end
    end)
end))

-- UPDATED HOOKS - All methods including index hooks
local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(...)
    local Method = getnamecallmethod()
    local Arguments = {...}
    local self = Arguments[1]
    local chance = CalculateChance(library.flags["SilentHitChance"] or 100)
    
    if library.flags["SilentAimEnabled"] and self == workspace and not checkcaller() and chance == true then
        local silentMethod = library.flags["SilentMethod"]
        
        if (Method == "FindPartOnRayWithIgnoreList" and (silentMethod == Method or silentMethod == "All Methods")) then
            if ValidateArguments(Arguments, ExpectedArguments.FindPartOnRayWithIgnoreList) then
                local A_Ray = Arguments[2]
                local HitPart = getClosestPlayer()
                if HitPart then
                    local Origin = A_Ray.Origin
                    local Direction = getDirection(Origin, HitPart.Position)
                    Arguments[2] = Ray.new(Origin, Direction)
                    return oldNamecall(unpack(Arguments))
                end
            end
        elseif (Method == "FindPartOnRayWithWhitelist" and (silentMethod == Method or silentMethod == "All Methods")) then
            if ValidateArguments(Arguments, ExpectedArguments.FindPartOnRayWithWhitelist) then
                local A_Ray = Arguments[2]
                local HitPart = getClosestPlayer()
                if HitPart then
                    local Origin = A_Ray.Origin
                    local Direction = getDirection(Origin, HitPart.Position)
                    Arguments[2] = Ray.new(Origin, Direction)
                    return oldNamecall(unpack(Arguments))
                end
            end
        elseif (Method == "FindPartOnRay" and (silentMethod == Method or silentMethod == "All Methods")) then
            if ValidateArguments(Arguments, ExpectedArguments.FindPartOnRay) then
                local A_Ray = Arguments[2]
                local HitPart = getClosestPlayer()
                if HitPart then
                    local Origin = A_Ray.Origin
                    local Direction = getDirection(Origin, HitPart.Position)
                    Arguments[2] = Ray.new(Origin, Direction)
                    return oldNamecall(unpack(Arguments))
                end
            end
        elseif (Method == "Raycast" and (silentMethod == Method or silentMethod == "All Methods")) then
            if ValidateArguments(Arguments, ExpectedArguments.Raycast) then
                local A_Origin = Arguments[2]
                local HitPart = getClosestPlayer()
                if HitPart then
                    Arguments[3] = getDirection(A_Origin, HitPart.Position)
                    return oldNamecall(unpack(Arguments))
                end
            end
        end
    end
    return oldNamecall(...)
end))

-- Index hook for additional methods
local oldIndex
oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, key)
    if library.flags["SilentAimEnabled"] and not checkcaller() then
        local silentMethod = library.flags["SilentMethod"]
        
        if key == "Hit" and (silentMethod == "Mouse.Hit" or silentMethod == "All Methods") then
            local HitPart = getClosestPlayer()
            if HitPart then
                return HitPart.CFrame
            end
        elseif key == "Target" and (silentMethod == "Mouse.Target" or silentMethod == "All Methods") then
            local HitPart = getClosestPlayer()
            if HitPart then
                return HitPart
            end
        elseif key == "UnitRay" and (silentMethod == "Mouse.UnitRay" or silentMethod == "All Methods") then
            local HitPart = getClosestPlayer()
            if HitPart then
                return Ray.new(Camera.CFrame.Position, (HitPart.Position - Camera.CFrame.Position).Unit)
            end
        end
    end
    return oldIndex(self, key)
end))

-- Alternative method using GetMouseLocation hook
local oldGetMouseLocation
oldGetMouseLocation = hookfunction(UserInputService.GetMouseLocation, function(...)
    if library.flags["SilentAimEnabled"] and library.flags["SilentMethod"] == "GetMouseLocation" then
        local HitPart = getClosestPlayer()
        if HitPart then
            local Vec3, OnScreen = WorldToViewportPoint(Camera, HitPart.Position)
            if OnScreen then
                return Vector2.new(Vec3.X, Vec3.Y)
            end
        end
    end
    return oldGetMouseLocation(...)
end)
