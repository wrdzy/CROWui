--==========AIMLOCK SECTION==========
-- Core Services
local Players            = game:GetService("Players")
local RunService         = game:GetService("RunService")
local UserInputService   = game:GetService("UserInputService")
local Camera             = workspace.CurrentCamera

-- Player References
local LocalPlayer        = Players.LocalPlayer
local Mouse              = LocalPlayer:GetMouse()

-- Drawing Objects
local FOVCircle          = Drawing.new("Circle")
FOVCircle.Thickness      = 2
FOVCircle.NumSides       = 60
FOVCircle.Position       = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
FOVCircle.Radius         = 100
FOVCircle.Color          = Color3.new(1,1,1)
FOVCircle.Transparency   = 1 - 0.5
FOVCircle.Visible        = false

local InfoBox            = Drawing.new("Square")
InfoBox.Size             = Vector2.new(200, 60)
InfoBox.Position         = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
InfoBox.Filled           = true
InfoBox.Visible          = false

local InfoBorder         = Drawing.new("Square")
InfoBorder.Size          = Vector2.new(200, 60)
InfoBorder.Position      = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
InfoBorder.Filled        = false
InfoBorder.Thickness      = 2
InfoBorder.Visible       = false

local StatusText         = Drawing.new("Text")
StatusText.Size          = 20
StatusText.Outline       = true
StatusText.Position      = Vector2.new(Camera.ViewportSize.X/2+5, Camera.ViewportSize.Y/2+5)
StatusText.Visible       = false

local HealthText         = Drawing.new("Text")
HealthText.Size          = 20
HealthText.Outline       = true
HealthText.Position      = Vector2.new(Camera.ViewportSize.X/2+5, Camera.ViewportSize.Y/2+30)
HealthText.Visible       = false

local TargetIndicator    = Drawing.new("Circle")
TargetIndicator.Thickness = 2
TargetIndicator.NumSides = 4
TargetIndicator.Radius   = 5
TargetIndicator.Color     = Color3.new(1,1,1)
TargetIndicator.Transparency = 1 - 0.5
TargetIndicator.Visible  = false

-- State Variables
local CurrentTarget      = nil
local CurrentTargetPart  = nil
local AimlockConnection  = nil
local MouseMoveConnection= nil
local LastShotTime       = 0
local AutoShootCooldown  = 0.02

local STICKY_RANGE       = 15
local FOV_OFFSET_Y       = 57
local INDICATOR_OFFSET_Y = 57

-- Body Part Definitions (R6 & R15)
local BodyPartDefinitions = {
    Head  = {"Head"},
    Torso = {"HumanoidRootPart"},
    Legs  = {"Left Leg","LeftUpperLeg"}
}
local TargetPartOptions = {"Head","Torso","Legs"}

-- Utility Functions
local function FixTransparency(value)
    return 1 - value
end

local function HasForceField(character)
    if not character then return false end
    return character:FindFirstChildWhichIsA("ForceField") ~= nil
end

local function IsVisible(player, part)
    if not player or not player.Character or not part then return false end
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {LocalPlayer.Character}
    local origin = Camera.CFrame.Position
    local dir    = part.Position - origin
    local hit    = workspace:Raycast(origin, dir, params)
    return not (hit and not hit.Instance:IsDescendantOf(player.Character))
end

local function GetBestTargetPart(player, selectedParts)
    if not player or not player.Character then return nil end
    local valid = {}
    local wallCheck = library.flags["WallCheck"]
    for _, partType in ipairs(selectedParts) do
        local names = BodyPartDefinitions[partType]
        if names then
            for _, name in ipairs(names) do
                local part = player.Character:FindFirstChild(name)
                if part and part:IsA("BasePart") then
                    if not wallCheck or IsVisible(player, part) then
                        table.insert(valid, part)
                    end
                end
            end
        end
    end
    
    if #valid == 0 then return nil end
    
    if #selectedParts > 1 then
        local randomIndex = math.random(1, #valid)
        return valid[randomIndex]
    else
        local closest, minDist = nil, math.huge
        local refPoint
        if library.flags["AimMethod"] == "Camera" then
            refPoint = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
        else
            refPoint = Vector2.new(Mouse.X, Mouse.Y + FOV_OFFSET_Y)
        end

        for _, part in ipairs(valid) do
            local sp = Camera:WorldToScreenPoint(part.Position)
            if sp.Z > 0 then
                local screenPos = Vector2.new(sp.X, sp.Y)
                local dist = (screenPos - refPoint).Magnitude
                if dist < minDist then
                    closest, minDist = part, dist
                end
            end
        end
        return closest
    end
end

local function ApplyPrediction(part)
    local mode = library.flags["PredictionMode"]
    if mode == "Off" then return part.Position end
    local vel = part.Velocity
    if mode == "Manual" then
        return part.Position + vel * (library.flags["ManualPrediction"] or 0)
    elseif mode == "Auto" then
        local dist = (Camera.CFrame.Position - part.Position).Magnitude
        return part.Position + vel * (dist / 200)
    end
    return part.Position
end

local function CalculateMove(dx, dy)
    local smooth = library.flags["Smoothness"] or 0
    local stickyAim = library.flags["StickyAim"] or false
    
    if stickyAim then
        local dist = math.sqrt(dx*dx + dy*dy)
        if dist < STICKY_RANGE then
            local slowFactor = dist / STICKY_RANGE
            dx = dx * (slowFactor * 0.5)
            dy = dy * (slowFactor * 0.5)
        end
    end
    
    dx = dx * (1 - smooth)
    dy = dy * (1 - smooth)
    
    return dx, dy
end

local function UpdateFOVPosition()
    if library.flags["AimMethod"] == "Camera" then
        FOVCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    else
        FOVCircle.Position = Vector2.new(Mouse.X, Mouse.Y + FOV_OFFSET_Y)
    end
end

local function UpdateInfoUIVisibility()
    if not library.flags["ShowInfoUI"] or not CurrentTarget then
        InfoBox.Visible = false
        InfoBorder.Visible = false
        StatusText.Visible = false
        HealthText.Visible = false
        TargetIndicator.Visible = false
        return
    end

    InfoBox.Visible   = false
    InfoBorder.Visible= false
    StatusText.Visible= false

    StatusText.Text = "Target: " .. CurrentTarget.Name ..
        (CurrentTargetPart and " ("..CurrentTargetPart.Name..")" or "")

    local humanoid = CurrentTarget.Character and CurrentTarget.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        HealthText.Visible = false
        HealthText.Text    = "Health: " .. math.floor(humanoid.Health)
        if library.flags["DynamicHealthColor"] then
            local pct = humanoid.Health / humanoid.MaxHealth
            HealthText.Color = Color3.fromRGB(255*(1-pct),255*pct,0)
        else
            HealthText.Color       = library.flags["HealthTextColor"] or Color3.new(0,1,0)
            HealthText.Transparency= FixTransparency(library.flags["HealthTextTrans"] or 0)
        end
    else
        HealthText.Visible = false
    end
end

local function SetupFOVTracking()
    if MouseMoveConnection then MouseMoveConnection:Disconnect() end
    
    if library.flags["AimMethod"] == "Mouse" then
        MouseMoveConnection = UserInputService.InputChanged:Connect(function(i)
            if i.UserInputType == Enum.UserInputType.MouseMovement then
                FOVCircle.Position = Vector2.new(Mouse.X, Mouse.Y + FOV_OFFSET_Y)
            end
        end)
    end
end

local function Cleanup()
    if AimlockConnection then AimlockConnection:Disconnect() end
    if MouseMoveConnection then MouseMoveConnection:Disconnect() end
    AimlockConnection, MouseMoveConnection = nil, nil
end

-- Create target display labels (add these to UI section)
_G.CROW.targetName = nil
_G.CROW.targetDisplay = nil
_G.CROW.targetHealth = nil
_G.CROW.targetDistance = nil
_G.CROW.targetTool = nil

local function UpdateTargetIndicator(target, targetPart)
    if not target or not target.Character then
        if _G.CROW.targetName then _G.CROW.targetName:SetValue('nil') end
        if _G.CROW.targetDisplay then _G.CROW.targetDisplay:SetValue('nil') end
        if _G.CROW.targetHealth then _G.CROW.targetHealth:SetValue('0') end
        if _G.CROW.targetDistance then _G.CROW.targetDistance:SetValue('0m') end
        if _G.CROW.targetTool then _G.CROW.targetTool:SetValue('nil') end
        return
    end
    
    if _G.CROW.targetName then _G.CROW.targetName:SetValue(target.Name) end
    local displayName = target.DisplayName or target.Name
    if _G.CROW.targetDisplay then _G.CROW.targetDisplay:SetValue(displayName) end
    
    local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        local healthText = math.floor(humanoid.Health) .. "/" .. math.floor(humanoid.MaxHealth)
        if _G.CROW.targetHealth then _G.CROW.targetHealth:SetValue(healthText) end
    else
        if _G.CROW.targetHealth then _G.CROW.targetHealth:SetValue('0/0') end
    end
    
    local localCharacter = LocalPlayer.Character
    if localCharacter and localCharacter:FindFirstChild("HumanoidRootPart") and target.Character:FindFirstChild("HumanoidRootPart") then
        local distance = (localCharacter.HumanoidRootPart.Position - target.Character.HumanoidRootPart.Position).Magnitude
        if _G.CROW.targetDistance then _G.CROW.targetDistance:SetValue(math.floor(distance) .. 'm') end
    else
        if _G.CROW.targetDistance then _G.CROW.targetDistance:SetValue('0m') end
    end
    
    local tool = target.Character:FindFirstChildOfClass("Tool")
    if tool then
        if _G.CROW.targetTool then _G.CROW.targetTool:SetValue(tool.Name) end
    else
        if _G.CROW.targetTool then _G.CROW.targetTool:SetValue('nil') end
    end
end

local function StartAimlock()
    Cleanup()
    UpdateFOVPosition()
    SetupFOVTracking()
    math.randomseed(tick())

    AimlockConnection = RunService.RenderStepped:Connect(function()
        if not library.flags["AimlockEnabled"] then
            InfoBox.Visible = false
            InfoBorder.Visible = false
            StatusText.Visible = false
            HealthText.Visible = false
            TargetIndicator.Visible = false
            UpdateTargetIndicator(nil, nil)
            return
        end

        local teamCheck       = library.flags["TeamCheck"]
        local wallCheck       = library.flags["WallCheck"]
        local forceFieldCheck = library.flags["ForceFieldCheck"]
        local aimMethod       = library.flags["AimMethod"]
        local partsList       = library.flags["TargetParts"] or {"Head"}
        local fovSize         = library.flags["FOVSize"] or 100
        local autoShoot       = library.flags["AutoShoot"] or false

        FOVCircle.Radius  = fovSize
        FOVCircle.Visible = true

        if CurrentTarget then
            local char     = CurrentTarget.Character
            local humanoid = char and char:FindFirstChildOfClass("Humanoid")
            if not humanoid or humanoid.Health <= 0
            or (forceFieldCheck and HasForceField(char))
            or (wallCheck and CurrentTargetPart and not IsVisible(CurrentTarget, CurrentTargetPart)) then
                CurrentTarget, CurrentTargetPart = nil, nil
                UpdateInfoUIVisibility()
                TargetIndicator.Visible = false
                UpdateTargetIndicator(nil, nil)
            end
        end

        if not CurrentTarget then
            local closest = fovSize
            for _, player in ipairs(Players:GetPlayers()) do
                if player == LocalPlayer then continue end
                local char     = player.Character
                local humanoid = char and char:FindFirstChildOfClass("Humanoid")
                if not humanoid or humanoid.Health <= 0 then continue end
                if teamCheck and player.Team == LocalPlayer.Team then continue end
                if forceFieldCheck and HasForceField(char) then continue end

                local part = GetBestTargetPart(player, partsList)
                if not part then continue end
                if wallCheck and not IsVisible(player, part) then continue end

                local sp = Camera:WorldToScreenPoint(part.Position)
                if sp.Z <= 0 then continue end

                local screenPos = Vector2.new(sp.X, sp.Y)
                local center
                if aimMethod == "Camera" then
                    center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
                else
                    center = Vector2.new(Mouse.X, Mouse.Y + FOV_OFFSET_Y)
                end
                local dist = (screenPos - center).Magnitude

                if dist < closest then
                    CurrentTarget, CurrentTargetPart = player, part
                    closest = dist
                end
            end
            UpdateInfoUIVisibility()
            UpdateTargetIndicator(CurrentTarget, CurrentTargetPart)
        end

        if CurrentTarget and CurrentTargetPart then
            UpdateInfoUIVisibility()
            UpdateTargetIndicator(CurrentTarget, CurrentTargetPart)
            
            local targetPos = ApplyPrediction(CurrentTargetPart)

            if aimMethod == "Camera" then
                local goal = CFrame.new(Camera.CFrame.Position, targetPos)
                local smooth = library.flags["Smoothness"] or 0
                Camera.CFrame = Camera.CFrame:Lerp(goal, 1 - smooth)
            else
                local sp = Camera:WorldToScreenPoint(targetPos)
                if sp.Z > 0 then
                    local dx, dy = sp.X - Mouse.X, sp.Y - Mouse.Y
                    local mx, my = CalculateMove(dx, dy)
                    if mx ~= 0 or my ~= 0 then
                        mousemoverel(mx, my)
                    end
                end
            end

            local sp2 = Camera:WorldToScreenPoint(targetPos)
            if sp2.Z > 0 then
                TargetIndicator.Position = Vector2.new(sp2.X, sp2.Y + INDICATOR_OFFSET_Y)
                TargetIndicator.Visible = true
                
                if autoShoot and tick() - LastShotTime >= AutoShootCooldown then
                    mouse1press()
                    wait()
                    mouse1release()
                    LastShotTime = tick()
                end
            else
                TargetIndicator.Visible = false
            end
        end
    end)
end

local function StopAimlock()
    Cleanup()
    FOVCircle.Visible = false
    InfoBox.Visible = false
    InfoBorder.Visible = false
    StatusText.Visible = false
    HealthText.Visible = false
    TargetIndicator.Visible = false
    CurrentTarget, CurrentTargetPart = nil, nil
    UpdateTargetIndicator(nil, nil)
end

-- UI Section
local secaim = _G.Aimlock:AddSection("Aim Lock", 1)

secaim:AddSeparator({ text = "Main" })

local aimlockToggle = secaim:AddToggle({
    text    = "Key Aim Lock",
    state   = false,
    flag    = "AimlockEnabled",
    tooltip = "Toggle the aim lock",
    callback= function(on)
        if on then StartAimlock() else StopAimlock() end
    end
})
:AddBind({
    text     = "Toggle Aim Lock",
    mode     = "toggle",
    bind     = "NONE",
    flag     = "ToggleKey_1",
    callback = function(on)
        if on then StartAimlock() else StopAimlock() end
    end
})

-- Autoshoot Toggle
secaim:AddToggle({
    text    = "Auto Shoot",
    state   = false,
    flag    = "AutoShoot",
    tooltip = "Automatically shoot when targeting",
    callback= function(on)
        if not on then
            mouse1release()
        end
    end
})

secaim:AddToggle({
    text    = "Team Check",
    state   = false,
    flag    = "TeamCheck",
    tooltip = "Don't target teammates",
    callback= function() CurrentTarget, CurrentTargetPart = nil, nil end
})

secaim:AddToggle({
    text    = "Wall Check",
    state   = false,
    flag    = "WallCheck",
    tooltip = "Don't target through walls",
    callback= function() CurrentTarget, CurrentTargetPart = nil, nil end
})

secaim:AddToggle({
    text    = "ForceField Check",
    state   = false,
    flag    = "ForceFieldCheck",
    tooltip = "Don't target invulnerable players",
    callback= function() CurrentTarget, CurrentTargetPart = nil, nil end
})

secaim:AddToggle({
    text    = "Sticky Aim",
    state   = false,
    flag    = "StickyAim",
    tooltip = "Makes your aim stick to targets"
})

secaim:AddList({
    text     = "Aim Lock Method",
    selected = "Camera",
    values   = {"Camera","Mouse"},
    flag     = "AimMethod",
    tooltip  = "Choose aim method",
    callback = function()
        UpdateFOVPosition()
        SetupFOVTracking()
        CurrentTarget, CurrentTargetPart = nil, nil
    end
})

secaim:AddList({
    text     = "Target Body Parts",
    selected = {"Head"},
    multi    = true,
    values   = TargetPartOptions,
    flag     = "TargetParts",
    tooltip  = "Which body parts to aim at",
    callback = function() CurrentTarget, CurrentTargetPart = nil, nil end
})

secaim:AddSeparator({ text = "Misc" })

secaim:AddSlider({
    text      = "Mouse Smoothness",
    min       = 0,
    max       = 1.0,
    increment = 0.05,
    default   = 0,
    flag      = "Smoothness",
    tooltip   = "Higher = smoother"
})

secaim:AddSlider({
    text      = "FOV Size",
    min       = 50,
    max       = 500,
    increment = 1,
    default   = 100,
    suffix    = "px",
    flag      = "FOVSize",
    tooltip   = "Aim FOV radius",
    callback  = function(v)
        FOVCircle.Radius = v
        CurrentTarget, CurrentTargetPart = nil, nil
    end
})

secaim:AddSeparator({ text = "Prediction" })

secaim:AddList({
    text     = "Prediction Mode",
    selected = "Off",
    values   = {"Off","Manual","Auto"},
    flag     = "PredictionMode",
    tooltip  = "Aim prediction"
})

secaim:AddSlider({
    text      = "Manual Prediction",
    min       = 0,
    max       = 0.5,
    increment = 0.01,
    default   = 0,
    flag      = "ManualPrediction",
    tooltip   = "Manual prediction strength"
})

local secedit = _G.Aimlock:AddSection("Customize", 1)

secedit:AddSeparator({ text = "Colors" })
secedit:AddColor({
    text     = "FOV Circle Color",
    color    = Color3.new(1,1,1),
    trans    = 0.5,
    flag     = "FOVColor",
    tooltip  = "Circle color/transparency",
    callback = function(c,t)
        FOVCircle.Color        = c
        FOVCircle.Transparency = FixTransparency(t)
    end
})
secedit:AddColor({
    text     = "Indicator Color",
    color    = Color3.new(1,1,1),
    trans    = 0.5,
    flag     = "IndicatorColor",
    tooltip  = "Indicator color/transparency",
    callback = function(c,t)
        TargetIndicator.Color        = c
        TargetIndicator.Transparency = FixTransparency(t)
    end
})

-- ===================== OPTIMIZED SILENT AIM SECTION =====================
local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

-- Performance optimizations
local TARGET_CACHE_TIME = 0.1 -- Cache target for 100ms
local RENDER_CACHE_TIME = 0.033 -- ~30 FPS for rendering
local MOUSE_CACHE_TIME = 0.016 -- ~60 FPS for mouse

local CachedTarget = nil
local CachedTargetTime = 0
local CachedMousePos = Vector2.new(0, 0)
local CachedMouseTime = 0
local LastRenderTime = 0

-- Drawing Objects
local fov_circle = Drawing.new("Circle")
fov_circle.Thickness = 1
fov_circle.NumSides = 60 -- Reduced from 100
fov_circle.Radius = 50
fov_circle.Filled = false
fov_circle.Visible = false
fov_circle.ZIndex = 999
fov_circle.Transparency = 0.5
fov_circle.Color = Color3.new(1,1,1)

local SilentTargetIndicator = Drawing.new("Circle")
SilentTargetIndicator.Thickness = 2
SilentTargetIndicator.NumSides = 4
SilentTargetIndicator.Radius = 5
SilentTargetIndicator.Color = Color3.new(1,1,1)
SilentTargetIndicator.Transparency = 0.5
SilentTargetIndicator.Visible = false

-- Target parts mapping
local TARGET_PARTS = {
    Head = {"Head"},
    Torso = {"HumanoidRootPart"},
    Legs = {"Left Leg", "LeftUpperLeg"}
}

-- Optimized utility functions
function CalculateChance(Percentage)
    return math.random(1, 100) <= Percentage
end

local function getMousePosition()
    local currentTime = tick()
    if currentTime - CachedMouseTime > MOUSE_CACHE_TIME then
        CachedMousePos = UserInputService:GetMouseLocation()
        CachedMouseTime = currentTime
    end
    return CachedMousePos
end

local function getSelectedTargetParts()
    local selectedParts = {}
    local selectedBodyParts = library.flags["SilentTargetParts"] or {"Head"}
    
    for _, bodyPart in ipairs(selectedBodyParts) do
        if TARGET_PARTS[bodyPart] then
            for _, part in ipairs(TARGET_PARTS[bodyPart]) do
                table.insert(selectedParts, part)
            end
        end
    end
    
    if #selectedParts == 0 then
        selectedParts = TARGET_PARTS.Head
    end
    
    return selectedParts
end

local function getTargetPart(Character)
    local selectedParts = getSelectedTargetParts()
    local availableParts = {}
    
    for _, partName in ipairs(selectedParts) do
        local part = Character:FindFirstChild(partName)
        if part then
            table.insert(availableParts, part)
        end
    end
    
    if #availableParts > 0 then
        return availableParts[math.random(1, #availableParts)]
    else
        return Character:FindFirstChild("HumanoidRootPart")
    end
end

-- Highly optimized player visibility check
local function IsPlayerVisible(Player)
    if not library.flags["SilentVisibleCheck"] then return true end
    
    local Character = Player.Character
    local LocalCharacter = LocalPlayer.Character
    if not (Character and LocalCharacter) then return false end
    
    local PlayerRoot = Character:FindFirstChild("Head") or Character:FindFirstChild("HumanoidRootPart")
    if not PlayerRoot then return false end
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {LocalCharacter, Character}
    
    local result = workspace:Raycast(Camera.CFrame.Position, PlayerRoot.Position - Camera.CFrame.Position, raycastParams)
    return not result
end

-- Cached closest player function - MAJOR OPTIMIZATION
local function getClosestPlayer()
    local currentTime = tick()
    
    -- Return cached result if still valid
    if currentTime - CachedTargetTime < TARGET_CACHE_TIME and CachedTarget then
        -- Quick validity check
        if CachedTarget.Parent and CachedTarget.Parent.Parent == Players then
            local humanoid = CachedTarget.Parent:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                return CachedTarget
            end
        end
    end
    
    -- Find new target
    local mousePos = getMousePosition()
    local fovSize = library.flags["SilentFOVSize"] or 50
    local closestPart = nil
    local shortestDistance = fovSize
    
    -- Optimized player iteration
    for i, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if library.flags["SilentTeamCheck"] and player.Team == LocalPlayer.Team then continue end
        
        local character = player.Character
        if not character then continue end
        
        local humanoid = character:FindFirstChild("Humanoid")
        if not humanoid or humanoid.Health <= 0 then continue end
        
        if not IsPlayerVisible(player) then continue end
        
        local targetPart = getTargetPart(character)
        if not targetPart then continue end
        
        local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
        if not onScreen then continue end
        
        local distance = (mousePos - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
        if distance < shortestDistance then
            closestPart = targetPart
            shortestDistance = distance
        end
    end
    
    -- Update cache
    CachedTarget = closestPart
    CachedTargetTime = currentTime
    
    return closestPart
end

-- Optimized direction calculation
local function getDirection(Origin, Position)
    return (Position - Origin).Unit * 1000
end

-- UI remains the same...
local SilentAimSection = _G.Aimlock:AddSection("Silent Aim", 2)

SilentAimSection:AddSeparator({ text = "Main" })

SilentAimSection:AddToggle({
    text = "Enabled",
    state = false,
    flag = "SilentAimEnabled",
    callback = function(state)
        fov_circle.Visible = state
        SilentTargetIndicator.Visible = state and library.flags["SilentShowIndicator"]
        -- Clear cache when toggling
        CachedTarget = nil
        CachedTargetTime = 0
    end
}):AddBind({
    text = "Toggle Silent Aim",
    mode = "toggle",
    bind = "NONE",
    flag = "SilentAimToggleKey",
    callback = function(state)
        fov_circle.Visible = state
        SilentTargetIndicator.Visible = state and library.flags["SilentShowIndicator"]
        CachedTarget = nil
        CachedTargetTime = 0
    end
})

SilentAimSection:AddToggle({
    text = "Team Check",
    state = false,
    flag = "SilentTeamCheck",
    callback = function()
        CachedTarget = nil
        CachedTargetTime = 0
    end
})

SilentAimSection:AddToggle({
    text = "Visible Check",
    state = false,
    flag = "SilentVisibleCheck",
    callback = function()
        CachedTarget = nil
        CachedTargetTime = 0
    end
})

SilentAimSection:AddList({
    text = "Target Parts",
    selected = {"Head"},
    multi = true,
    values = {"Head", "Torso", "Legs"},
    flag = "SilentTargetParts",
    callback = function()
        CachedTarget = nil
        CachedTargetTime = 0
    end
})

SilentAimSection:AddList({
    text = "Silent Aim Method",
    selected = "Raycast",
    values = {"Raycast", "FindPartOnRayWithIgnoreList", "FindPartOnRayWithWhitelist", "FindPartOnRay"},
    flag = "SilentMethod"
})

SilentAimSection:AddSlider({
    text = "Hit Chance",
    min = 0,
    max = 100,
    increment = 1,
    default = 100,
    suffix = "%",
    flag = "SilentHitChance"
})

-- Customize Section
local SilentCustomizeSection = _G.Aimlock:AddSection("Silent Aim Customize", 2)

SilentCustomizeSection:AddSeparator({ text = "Field Of View" })

SilentCustomizeSection:AddSlider({
    text = "FOV Size",
    min = 50,
    max = 500,
    increment = 1,
    default = 50,
    suffix = "px",
    flag = "SilentFOVSize",
    callback = function(value)
        fov_circle.Radius = value
        CachedTarget = nil
        CachedTargetTime = 0
    end
})

SilentCustomizeSection:AddColor({
    text = "FOV Circle Color",
    color = Color3.new(1,1,1),
    trans = 0.5,
    flag = "SilentFOVColor",
    callback = function(color, trans)
        fov_circle.Color = color
        fov_circle.Transparency = 1 - trans
    end
})

SilentCustomizeSection:AddSeparator({ text = "Target Indicator" })

SilentCustomizeSection:AddToggle({
    text = "Show Target Indicator",
    state = false,
    flag = "SilentShowIndicator",
    callback = function(state)
        SilentTargetIndicator.Visible = state and library.flags["SilentAimEnabled"]
    end
})

SilentCustomizeSection:AddColor({
    text = "Indicator Color",
    color = Color3.new(1,1,1),
    trans = 0.5,
    flag = "SilentIndicatorColor",
    callback = function(color, trans)
        SilentTargetIndicator.Color = color
        SilentTargetIndicator.Transparency = 1 - trans
    end
})

-- OPTIMIZED RENDER LOOP - Major performance improvement
RunService.RenderStepped:Connect(function()
    local currentTime = tick()
    
    -- Limit render frequency to ~30 FPS
    if currentTime - LastRenderTime < RENDER_CACHE_TIME then
        return
    end
    LastRenderTime = currentTime
    
    -- Check if Silent Aim is enabled
    local silentAimEnabled = library.flags["SilentAimEnabled"]
    
    if not silentAimEnabled then
        fov_circle.Visible = false
        SilentTargetIndicator.Visible = false
        return
    end
    
    -- Update FOV circle position only when enabled
    fov_circle.Visible = true
    fov_circle.Position = getMousePosition()
    
    -- Update target indicator
    if library.flags["SilentShowIndicator"] then
        local target = getClosestPlayer()
        if target then 
            local screenPos, onScreen = Camera:WorldToViewportPoint(target.Position)
            SilentTargetIndicator.Visible = onScreen
            if onScreen then
                SilentTargetIndicator.Position = Vector2.new(screenPos.X, screenPos.Y)
            end
        else 
            SilentTargetIndicator.Visible = false 
        end
    else
        SilentTargetIndicator.Visible = false
    end
end)

-- OPTIMIZED HOOKS - Only hook what's necessary
local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(...)
    local Method = getnamecallmethod()
    local Arguments = {...}
    local self = Arguments[1]
    
    -- Early exit checks for performance
    if not library.flags["SilentAimEnabled"] then
        return oldNamecall(...)
    end
    
    if checkcaller() then
        return oldNamecall(...)
    end
    
    if self ~= workspace then
        return oldNamecall(...)
    end
    
    -- Check hit chance early
    if not CalculateChance(library.flags["SilentHitChance"] or 100) then
        return oldNamecall(...)
    end
    
    local silentMethod = library.flags["SilentMethod"]
    
    -- Only process specific methods
    if Method == "Raycast" and silentMethod == "Raycast" then
        if #Arguments >= 3 then
            local HitPart = getClosestPlayer()
            if HitPart then
                Arguments[3] = getDirection(Arguments[2], HitPart.Position)
            end
        end
    elseif Method == "FindPartOnRayWithIgnoreList" and silentMethod == "FindPartOnRayWithIgnoreList" then
        if #Arguments >= 3 then
            local HitPart = getClosestPlayer()
            if HitPart then
                local A_Ray = Arguments[2]
                Arguments[2] = Ray.new(A_Ray.Origin, getDirection(A_Ray.Origin, HitPart.Position))
            end
        end
    elseif Method == "FindPartOnRayWithWhitelist" and silentMethod == "FindPartOnRayWithWhitelist" then
        if #Arguments >= 3 then
            local HitPart = getClosestPlayer()
            if HitPart then
                local A_Ray = Arguments[2]
                Arguments[2] = Ray.new(A_Ray.Origin, getDirection(A_Ray.Origin, HitPart.Position))
            end
        end
    elseif Method == "FindPartOnRay" and silentMethod == "FindPartOnRay" then
        if #Arguments >= 2 then
            local HitPart = getClosestPlayer()
            if HitPart then
                local A_Ray = Arguments[2]
                Arguments[2] = Ray.new(A_Ray.Origin, getDirection(A_Ray.Origin, HitPart.Position))
            end
        end
    end
    
    return oldNamecall(...)
end))
