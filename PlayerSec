-- Player Section
local secplayer = _G.PlayerTab:AddSection("Player", 1)
secplayer:AddSeparator({ text = "Player" })

-- Service References
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")

-- Player References
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character and character:WaitForChild("Humanoid", 5)
local camera = workspace.CurrentCamera

-- Validation checks
if not player then
    warn("LocalPlayer not found")
    return
end

if not camera then
    warn("Camera not found")
    return
end

-- Configuration values - Each feature has independent values
local speedValue = (humanoid and humanoid.WalkSpeed ~= 0) and humanoid.WalkSpeed or 16
local fovValue = camera.FieldOfView
local originalFov = camera.FieldOfView

-- Original lighting values storage
local originalLighting = {
    brightness = Lighting.Brightness,
    ambient = Lighting.Ambient,
    colorShift = Lighting.ColorShift_Top,
    fog = Lighting.FogEnd,
    shadowSoftness = Lighting.ShadowSoftness,
    time = Lighting.TimeOfDay,
    globalShadows = Lighting.GlobalShadows
}

-- Detect Jump Property
local jumpPropertyName = ""
local jumpValue, jumpMin, jumpMax, jumpMultiplier

local function detectJumpProperty()
    if not humanoid then return end
    
    if pcall(function() return humanoid.JumpPower end) then
        jumpPropertyName = "JumpPower"
        jumpValue = humanoid.JumpPower
        jumpMin = jumpValue
        jumpMax = jumpValue * 3
        jumpMultiplier = 1
    elseif pcall(function() return humanoid.JumpHeight end) then
        jumpPropertyName = "JumpHeight"
        jumpValue = humanoid.JumpHeight
        jumpMin = jumpValue
        jumpMax = jumpValue * 2
        jumpMultiplier = 0.5
    else
        jumpPropertyName = "JumpPower"
        jumpValue = 50
        jumpMin = jumpValue
        jumpMax = jumpValue * 3
        jumpMultiplier = 1
    end
end

detectJumpProperty()

-- States
local states = {
    speedEnabled = false,
    jumpEnabled = false,
    fovEnabled = false,
    --noclipEnabled = false,
    fullbrightEnabled = false
}

-- Movement State Tracking
local currentMovementMethod = "CFrame"
local connections = {}

-- Connection Management
local function trackConnection(connection, metadata)
    if metadata then
        table.insert(connections, {
            connection = connection,
            type = metadata
        })
    else
        table.insert(connections, connection)
    end
    return connection
end

-- Forward declarations for toggle functions
local toggleSpeed, toggleJump, toggleFOV, toggleFullBright--,toggleNoclip

-- Character Setup (called when character spawns or respawns)
local function setupCharacter(char)
    if not char then return end
    
    -- Update character references
    character = char
    
    -- Wait for humanoid to be available with timeout
    local waitTime = 0
    local maxWaitTime = 5
    
    while not character:FindFirstChild("Humanoid") and waitTime < maxWaitTime do
        task.wait(0.1)
        waitTime = waitTime + 0.1
    end
    
    humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then
        warn("Failed to find Humanoid after character respawn")
        return
    end
    
    -- Set default values
    if humanoid.WalkSpeed == 0 then
        humanoid.WalkSpeed = 16
    end
    
    -- Re-detect jump property for new character
    detectJumpProperty()
    
    if jumpPropertyName ~= "" then
        -- Set jump property
        if pcall(function() return humanoid[jumpPropertyName] end) then
            humanoid[jumpPropertyName] = states.jumpEnabled and jumpValue or jumpMin
        end
    end
    
    -- Reapply active states with a slight delay to ensure properties exist
    task.spawn(function()
        task.wait(0.2)
        if states.speedEnabled then toggleSpeed(true) end
        if states.jumpEnabled then toggleJump(true) end
        --if states.noclipEnabled then toggleNoclip(true) end
    end)
end

-- Movement Methods
local movementMethods = {
    ["CFrame"] = function()
        if not character or not character:FindFirstChild("Humanoid") then return end
        local humanoid = character:FindFirstChild("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return end
        
        local moveDirection = humanoid.MoveDirection
        if moveDirection.Magnitude > 0.1 then
            local normalizedDir = moveDirection.Unit
            local deltaTime = RunService.Heartbeat:Wait()
            local stepSize = speedValue * deltaTime * 0.85
            
            rootPart.CFrame = rootPart.CFrame + (normalizedDir * stepSize)
            rootPart.Velocity = Vector3.new(
                rootPart.Velocity.X * 0.7,
                rootPart.Velocity.Y,
                rootPart.Velocity.Z * 0.7
            )
        end
        
        -- Apply jump enhancement for CFrame method
        if states.jumpEnabled and humanoid:GetState() == Enum.HumanoidStateType.Jumping then
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                local jumpVelocity = rootPart.Velocity + Vector3.new(0, jumpValue * 0.5, 0)
                rootPart.Velocity = jumpVelocity
            end
        end
    end,
    
    ["Normal"] = function()
        if not character or not character:FindFirstChild("Humanoid") then return end
        local humanoid = character:FindFirstChild("Humanoid")
        
        if states.speedEnabled then
            humanoid.WalkSpeed = speedValue
        end
        
        if states.jumpEnabled and jumpPropertyName ~= "" then
            if pcall(function() return humanoid[jumpPropertyName] end) then
                humanoid[jumpPropertyName] = jumpValue
            end
        end
    end,
    
    ["Velocity"] = function()
        if not character or not character:FindFirstChild("Humanoid") then return end
        local humanoid = character:FindFirstChild("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return end
        
        local moveDirection = humanoid.MoveDirection
        if moveDirection.Magnitude > 0.1 then
            local normalizedDir = moveDirection.Unit
            
            rootPart.Velocity = Vector3.new(
                normalizedDir.X * speedValue * 1.2,
                rootPart.Velocity.Y,
                normalizedDir.Z * speedValue * 1.2
            )
        end
        
        if states.jumpEnabled and humanoid:GetState() == Enum.HumanoidStateType.Jumping then
            rootPart.Velocity = Vector3.new(
                rootPart.Velocity.X,
                jumpValue * 1.2,
                rootPart.Velocity.Z
            )
        end
    end,
    
    ["BodyVelocity"] = function()
        if not character or not character:FindFirstChild("Humanoid") then return end
        local humanoid = character:FindFirstChild("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return end
        
        local bodyVelocity = rootPart:FindFirstChild("MovementBodyVelocity")
        if not bodyVelocity then
            bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.Name = "MovementBodyVelocity"
            bodyVelocity.MaxForce = Vector3.new(100000, 0, 100000)
            bodyVelocity.P = 4000
            bodyVelocity.Parent = rootPart
        end
        
        local moveDirection = humanoid.MoveDirection
        if moveDirection.Magnitude > 0.1 then
            local normalizedDir = moveDirection.Unit
            bodyVelocity.Velocity = Vector3.new(
                normalizedDir.X * speedValue * 1.5,
                0,
                normalizedDir.Z * speedValue * 1.5
            )
        else
            bodyVelocity.Velocity = Vector3.new(0, 0, 0)
        end
        
        if states.jumpEnabled and humanoid:GetState() == Enum.HumanoidStateType.Jumping then
            local jumpVelocity = rootPart:FindFirstChild("JumpBodyVelocity")
            if not jumpVelocity then
                jumpVelocity = Instance.new("BodyVelocity")
                jumpVelocity.Name = "JumpBodyVelocity"
                jumpVelocity.MaxForce = Vector3.new(0, 100000, 0)
                jumpVelocity.P = 4000
                jumpVelocity.Parent = rootPart
            end
            
            jumpVelocity.Velocity = Vector3.new(0, jumpValue * 2, 0)
            
            task.spawn(function()
                task.wait(0.2)
                if jumpVelocity and jumpVelocity.Parent then
                    jumpVelocity:Destroy()
                end
            end)
        end
    end,
    
    ["Impulse"] = function()
        if not character or not character:FindFirstChild("Humanoid") then return end
        local humanoid = character:FindFirstChild("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return end
        
        local moveDirection = humanoid.MoveDirection
        if moveDirection.Magnitude > 0.1 then
            local normalizedDir = moveDirection.Unit
            local deltaTime = RunService.Heartbeat:Wait()
            local impulseForce = normalizedDir * speedValue * deltaTime * 20
            
            rootPart:ApplyImpulse(impulseForce)
        end
        
        if states.jumpEnabled and humanoid:GetState() == Enum.HumanoidStateType.Jumping then
            rootPart:ApplyImpulse(Vector3.new(0, jumpValue * 15, 0))
        end
    end
}

-- Function to clean up movement method effects
local function cleanupMovementMethod(methodName)
    if not character then return end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    
    if methodName == "BodyVelocity" or methodName == "all" then
        local bv = rootPart:FindFirstChild("MovementBodyVelocity")
        if bv then bv:Destroy() end
        
        local jumpBV = rootPart:FindFirstChild("JumpBodyVelocity")
        if jumpBV then jumpBV:Destroy() end
    end
end

-- FOV watcher - ensures FOV is always at the correct value
local function watchFOV()
    if not camera then return end
    trackConnection(camera:GetPropertyChangedSignal("FieldOfView"):Connect(function()
        if states.fovEnabled and camera.FieldOfView ~= fovValue then
            camera.FieldOfView = fovValue
        end
    end), "fov_watcher")
end

-- Continuous property enforcement
local function enforceProperties()
    -- Check if character exists
    if not workspace:FindFirstChild(player.Name) then
        return
    end
    
    if not character or not character.Parent then
        character = workspace:FindFirstChild(player.Name)
        if not character then return end
    end
    
    if not character:FindFirstChild("Humanoid") then return end
    local humanoid = character:FindFirstChild("Humanoid")
    
    -- FOV enforcement
    if states.fovEnabled and camera and camera.FieldOfView ~= fovValue then
        camera.FieldOfView = fovValue
    end
    
    -- -- Noclip enforcement
    -- if states.noclipEnabled then
    --     for _, part in ipairs(character:GetDescendants()) do
    --         if part:IsA("BasePart") then
    --             part.CanCollide = false
    --         end
    --     end
    -- end
    
    -- Jump enforcement
    if states.jumpEnabled and jumpPropertyName ~= "" then
        if pcall(function() return humanoid[jumpPropertyName] end) then
            if humanoid[jumpPropertyName] ~= jumpValue then
                humanoid[jumpPropertyName] = jumpValue
            end
        end
    end
    
    -- Speed enforcement for Normal method
    if currentMovementMethod == "Normal" and states.speedEnabled then
        if humanoid.WalkSpeed ~= speedValue then
            humanoid.WalkSpeed = speedValue
        end
    end
    
    -- FullBright enforcement
    if states.fullbrightEnabled then
        Lighting.Brightness = 2
        Lighting.ClockTime = 14
        Lighting.FogEnd = 100000
        Lighting.GlobalShadows = false
        Lighting.Ambient = Color3.fromRGB(178, 178, 178)
    end
end

-- Movement Controls
local function toggleMovement(state)
    states.speedEnabled = state
    
    -- Clean up previous movement connections
    for i = #connections, 1, -1 do
        local conn = connections[i]
        if type(conn) == "table" and conn.type == "movement" then
            conn.connection:Disconnect()
            table.remove(connections, i)
        end
    end
    
    cleanupMovementMethod("all")
    
    if state then
        trackConnection(RunService.Heartbeat:Connect(movementMethods[currentMovementMethod]), "movement")
    else
        if character and character:FindFirstChild("Humanoid") then
            character:FindFirstChild("Humanoid").WalkSpeed = 16
        end
    end
end

toggleSpeed = function(state)
    states.speedEnabled = state
    toggleMovement(state)
    
    if character and character:FindFirstChild("Humanoid") then
        character:FindFirstChild("Humanoid").WalkSpeed = state and speedValue or 16
    end
end

toggleJump = function(state)
    states.jumpEnabled = state
    
    if character and character:FindFirstChild("Humanoid") and jumpPropertyName ~= "" then
        if pcall(function() return character:FindFirstChild("Humanoid")[jumpPropertyName] end) then
            character:FindFirstChild("Humanoid")[jumpPropertyName] = state and jumpValue or jumpMin
        end
    end
end

toggleFOV = function(state)
    states.fovEnabled = state
    
    if not camera then return end
    
    if state then
        camera.FieldOfView = fovValue
    else
        camera.FieldOfView = originalFov
    end
    
    watchFOV()
end

-- toggleNoclip = function(state)
--     states.noclipEnabled = state
    
--     for i = #connections, 1, -1 do
--         local conn = connections[i]
--         if type(conn) == "table" and conn.type == "noclip" then
--             conn.connection:Disconnect()
--             table.remove(connections, i)
--         end
--     end
    
--     if state then
--         trackConnection(RunService.Heartbeat:Connect(function()
--             if not character or not character.Parent then return end
            
--             for _, part in ipairs(character:GetDescendants()) do
--                 if part:IsA("BasePart") then
--                     part.CanCollide = false
--                 end
--             end
--         end), "noclip")
--     else
--         if character then
--             for _, part in ipairs(character:GetDescendants()) do
--                 if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
--                     part.CanCollide = true
--                 end
--             end
--         end
--     end
-- end

toggleFullBright = function(state)
    states.fullbrightEnabled = state
    
    for i = #connections, 1, -1 do
        local conn = connections[i]
        if type(conn) == "table" and conn.type == "fullbright" then
            conn.connection:Disconnect()
            table.remove(connections, i)
        end
    end
    
    if state then
        originalLighting = {
            brightness = Lighting.Brightness,
            ambient = Lighting.Ambient,
            colorShift = Lighting.ColorShift_Top,
            fog = Lighting.FogEnd,
            shadowSoftness = Lighting.ShadowSoftness,
            time = Lighting.TimeOfDay,
            globalShadows = Lighting.GlobalShadows
        }
        
        Lighting.Brightness = 2
        Lighting.ClockTime = 14
        Lighting.FogEnd = 100000
        Lighting.GlobalShadows = false
        Lighting.Ambient = Color3.fromRGB(178, 178, 178)
        
        trackConnection(RunService.Heartbeat:Connect(function()
            Lighting.Brightness = 2
            Lighting.ClockTime = 14
            Lighting.FogEnd = 100000
            Lighting.GlobalShadows = false
        end), "fullbright")
    else
        Lighting.Brightness = originalLighting.brightness
        Lighting.Ambient = originalLighting.ambient
        Lighting.ColorShift_Top = originalLighting.colorShift
        Lighting.FogEnd = originalLighting.fog
        Lighting.ShadowSoftness = originalLighting.shadowSoftness
        Lighting.TimeOfDay = originalLighting.time
        Lighting.GlobalShadows = originalLighting.globalShadows
    end
end

local function updateMovementMethod(method)
    cleanupMovementMethod(currentMovementMethod)
    currentMovementMethod = method
    
    if states.speedEnabled then
        toggleMovement(false)
        toggleMovement(true)
    end
end

-- Connect to CharacterAdded event to handle respawns
trackConnection(player.CharacterAdded:Connect(setupCharacter))

-- Set up the continuous properties enforcement
trackConnection(RunService.RenderStepped:Connect(enforceProperties), "properties_enforcement")

-- Initial FOV watcher setup
watchFOV()

-- Cleanup Function
local function cleanupStats()
    for i = #connections, 1, -1 do
        local conn = connections[i]
        if type(conn) == "table" and conn.connection then
            conn.connection:Disconnect()
        elseif type(conn) == "userdata" then
            conn:Disconnect()
        end
        table.remove(connections, i)
    end
    
    cleanupMovementMethod("all")
    
    if character and character:FindFirstChild("Humanoid") then
        character:FindFirstChild("Humanoid").WalkSpeed = 16
        if jumpPropertyName ~= "" then
            if pcall(function() return character:FindFirstChild("Humanoid")[jumpPropertyName] end) then
                character:FindFirstChild("Humanoid")[jumpPropertyName] = jumpMin
            end
        end
    end
    
    if camera then
        camera.FieldOfView = originalFov
    end
    
    if states.fullbrightEnabled then
        toggleFullBright(false)
    end
    
    states.speedEnabled = false
    states.jumpEnabled = false
    states.fovEnabled = false
    -- states.noclipEnabled = false
    states.fullbrightEnabled = false
end

-- UI ELEMENTS
local movementDropdown = secplayer:AddList({
    text = "Movement Method",
    tooltip = "Select player movement method",
    selected = "CFrame",
    multi = false,
    values = { "CFrame", "Normal", "Velocity", "BodyVelocity", "Impulse" },
    callback = function(v)
        updateMovementMethod(v)
    end
})

local speedSlider = secplayer:AddSlider({
    text = "WalkSpeed",
    tooltip = "Adjust player movement speed",
    flag = "walkspeed",
    min = 16,
    max = 150,
    increment = 1,
    callback = function(v)
        speedValue = v
        if states.speedEnabled and character and character:FindFirstChild("Humanoid") then
            if currentMovementMethod == "Normal" then
                character:FindFirstChild("Humanoid").WalkSpeed = speedValue
            end
        end
    end
})

secplayer:AddToggle({
    text = "Speed",
    state = false,
    tooltip = "Toggle custom movement speed",
    flag = "Toggle_Speed",
    callback = function(state)
        toggleSpeed(state)
    end
}):AddBind({
    text = "Speed Key",
    tooltip = "Hotkey to toggle speed",
    mode = "toggle",
    bind = "None",
    callback = function(v)
        toggleSpeed(v)
    end
})

local jumpSlider = secplayer:AddSlider({
    text = jumpPropertyName,
    tooltip = "Adjust jump height/power",
    flag = "jumpvalue",
    min = jumpMin,
    max = jumpMax,
    increment = jumpMultiplier,
    callback = function(v)
        jumpValue = v
        if states.jumpEnabled and character and character:FindFirstChild("Humanoid") and jumpPropertyName ~= "" then
            if pcall(function() return character:FindFirstChild("Humanoid")[jumpPropertyName] end) then
                character:FindFirstChild("Humanoid")[jumpPropertyName] = jumpValue
            end
        end
    end
})

secplayer:AddToggle({
    text = "Jump",
    state = false,
    tooltip = "Toggle custom jump height",
    flag = "Toggle_Jump",
    callback = function(state)
        toggleJump(state)
    end
}):AddBind({
    text = "Jump Key",
    tooltip = "Hotkey to toggle jump",
    mode = "toggle",
    bind = "None",
    callback = function(v)
        toggleJump(v)
    end
})

secplayer:AddSeparator({ text = "" })

-- secplayer:AddToggle({
--     text = "Noclip",
--     state = false,
--     tooltip = "Toggle noclip mode",
--     flag = "Toggle_Noclip",
--     callback = function(state)
--         toggleNoclip(state)
--     end
-- }):AddBind({
--     text = "Noclip Key",
--     tooltip = "Hotkey to toggle noclip mode",
--     mode = "toggle",
--     bind = "None",
--     callback = function(v)
--         toggleNoclip(v)
--     end
-- })

secplayer:AddSeparator({ text = "Misc" })

local fovSlider = secplayer:AddSlider({
    text = "Field of View",
    tooltip = "Adjust camera field of view",
    flag = "fov",
    min = originalFov,
    max = 120,
    increment = 1,
    callback = function(v)
        fovValue = v
        if states.fovEnabled and camera then
            camera.FieldOfView = v
        end
    end
})

secplayer:AddToggle({
    text = "FOV",
    state = false,
    tooltip = "Toggle custom field of view",
    flag = "Toggle_FOV",
    callback = function(state)
        toggleFOV(state)
    end
}):AddBind({
    text = "FOV Key",
    tooltip = "Hotkey to toggle FOV",
    mode = "toggle",
    bind = "None",
    callback = function(v)
        toggleFOV(v)
    end
})

secplayer:AddToggle({
    text = "FullBright",
    state = false,
    tooltip = "Toggle full brightness lighting",
    flag = "Toggle_FullBright",
    callback = function(state)
        toggleFullBright(state)
    end
}):AddBind({
    text = "FullBright Key",
    tooltip = "Hotkey to toggle full brightness",
    mode = "toggle",
    bind = "None",
    callback = function(v)
        toggleFullBright(v)
    end
})


--=============================CUSTOMISATION============================
-- -- Character Customization Section
-- local seccharacter = _G.PlayerTab:AddSection("Character Customization", 2)
-- seccharacter:AddSeparator({ text = "Character Effects" })

-- -- State for character effects
-- local characterEffects = {
--     rainbowEnabled = false,
--     customColorEnabled = false,
--     customColor = Color3.fromRGB(255, 255, 255),
--     rainbowSpeed = 1,
--     rainbowConnection = nil,
--     originalColors = {},
--     materialEnabled = false,
--     selectedMaterial = "ForceField",
--     transparencyEnabled = false,
--     transparencyValue = 0.5,
--     zigzagCounter = 1
-- }

-- -- Zigzag function for rainbow effect
-- local function zigzag(X)
--     return math.acos(math.cos(X * math.pi)) / math.pi
-- end

-- -- Function to store original properties
-- local function storeOriginalColors()
--     characterEffects.originalColors = {}
--     if character then
--         for _, obj in ipairs(character:GetDescendants()) do
--             -- Include Head but handle accessories/hats separately
--             if (obj:IsA("BasePart") or obj:IsA("MeshPart") or obj:IsA("UnionOperation")) and obj.Parent and 
--                obj.Name ~= "HumanoidRootPart" then
--                 -- Check if the part is inside an accessory
--                 local isAccessory = obj.Parent and obj.Parent:IsA("Accessory")
--                 characterEffects.originalColors[obj] = {
--                     Color = obj.Color,
--                     Material = obj.Material,
--                     Transparency = obj.Transparency,
--                     SurfaceAppearance = obj:FindFirstChildOfClass("SurfaceAppearance") and obj:FindFirstChildOfClass("SurfaceAppearance").Transparency or nil,
--                     IsAccessory = isAccessory -- Track if it's an accessory
--                 }
--             elseif (obj:IsA("Decal") or obj:IsA("Texture")) then
--                 -- Include face decal but mark it specially
--                 characterEffects.originalColors[obj] = {
--                     Transparency = obj.Transparency,
--                     IsFace = obj.Name == "face"
--                 }
--             end
--         end
--     end
    
--     local arms = workspace.Camera:FindFirstChild("Arms")
--     if arms then
--         for _, obj in ipairs(arms:GetDescendants()) do
--             if (obj:IsA("MeshPart") or obj:IsA("BasePart") or obj:IsA("UnionOperation")) and obj.Parent then
--                 characterEffects.originalColors[obj] = {
--                     Color = obj.Color,
--                     Material = obj.Material,
--                     Transparency = obj.Transparency,
--                     SurfaceAppearance = obj:FindFirstChildOfClass("SurfaceAppearance") and obj:FindFirstChildOfClass("SurfaceAppearance").Transparency or nil,
--                     IsArms = true
--                 }
--             end
--         end
--     end
-- end

-- -- Function to restore original properties
-- local function restoreOriginalColors()
--     for obj, properties in pairs(characterEffects.originalColors) do
--         if obj and obj.Parent then
--             if (obj:IsA("BasePart") or obj:IsA("MeshPart") or obj:IsA("UnionOperation")) and 
--                obj.Name ~= "HumanoidRootPart" then
--                 obj.Color = properties.Color
--                 if not characterEffects.materialEnabled then
--                     obj.Material = properties.Material
--                 end
--                 if not characterEffects.transparencyEnabled then
--                     obj.Transparency = properties.Transparency
--                     local surfaceAppearance = obj:FindFirstChildOfClass("SurfaceAppearance")
--                     if surfaceAppearance and properties.SurfaceAppearance then
--                         surfaceAppearance.Transparency = properties.SurfaceAppearance
--                     end
--                 end
--             elseif (obj:IsA("Decal") or obj:IsA("Texture")) then
--                 if not characterEffects.transparencyEnabled then
--                     obj.Transparency = properties.Transparency
--                 end
--             end
--         end
--     end
-- end

-- -- Function to apply rainbow effect
-- local function applyRainbowEffect()
--     if not character then return end
    
--     local hue = (tick() * characterEffects.rainbowSpeed) % 1
--     local color = Color3.fromHSV(hue, 1, 1)
    
--     for _, obj in ipairs(character:GetDescendants()) do
--         -- Include Head but handle accessories carefully
--         if (obj:IsA("BasePart") or obj:IsA("MeshPart") or obj:IsA("UnionOperation")) and obj.Parent and 
--            obj.Name ~= "HumanoidRootPart" then
--             -- Check if it's an accessory part
--             local isAccessory = obj.Parent and obj.Parent:IsA("Accessory")
            
--             -- Apply color to all parts including head, but be careful with accessories
--             if not isAccessory or obj.Name == "Handle" then -- Only apply to accessory handles, not other accessory parts
--                 obj.Color = color
--             end
            
--             if characterEffects.transparencyEnabled then
--                 local surfaceAppearance = obj:FindFirstChildOfClass("SurfaceAppearance")
--                 if surfaceAppearance then
--                     surfaceAppearance.Transparency = characterEffects.transparencyValue
--                 end
--             end
--         end
--     end
    
--     local arms = workspace.Camera:FindFirstChild("Arms")
--     if arms then
--         for _, v in ipairs(arms:GetDescendants()) do
--             if (v:IsA("MeshPart") or v:IsA("BasePart") or v:IsA("UnionOperation")) and v.Parent then
--                 local zigzagHue = zigzag(characterEffects.zigzagCounter)
--                 v.Color = Color3.fromHSV(zigzagHue, 1, 1)
--                 if characterEffects.transparencyEnabled then
--                     local surfaceAppearance = v:FindFirstChildOfClass("SurfaceAppearance")
--                     if surfaceAppearance then
--                         surfaceAppearance.Transparency = characterEffects.transparencyValue
--                     end
--                 end
--             end
--         end
--         characterEffects.zigzagCounter = characterEffects.zigzagCounter + (0.01 * characterEffects.rainbowSpeed)
--     end
-- end

-- -- Function to apply custom color
-- local function applyCustomColor()
--     if not character then return end
    
--     for _, obj in ipairs(character:GetDescendants()) do
--         -- Include Head but handle accessories carefully
--         if (obj:IsA("BasePart") or obj:IsA("MeshPart") or obj:IsA("UnionOperation")) and obj.Parent and 
--            obj.Name ~= "HumanoidRootPart" then
--             -- Check if it's an accessory part
--             local isAccessory = obj.Parent and obj.Parent:IsA("Accessory")
            
--             -- Apply color to all parts including head, but be careful with accessories
--             if not isAccessory or obj.Name == "Handle" then -- Only apply to accessory handles, not other accessory parts
--                 obj.Color = characterEffects.customColor
--             end
            
--             if characterEffects.transparencyEnabled then
--                 local surfaceAppearance = obj:FindFirstChildOfClass("SurfaceAppearance")
--                 if surfaceAppearance then
--                     surfaceAppearance.Transparency = characterEffects.transparencyValue
--                 end
--             end
--         end
--     end
    
--     local arms = workspace.Camera:FindFirstChild("Arms")
--     if arms then
--         for _, v in ipairs(arms:GetDescendants()) do
--             if (v:IsA("MeshPart") or v:IsA("BasePart") or v:IsA("UnionOperation")) and v.Parent then
--                 v.Color = characterEffects.customColor
--                 if characterEffects.transparencyEnabled then
--                     local surfaceAppearance = v:FindFirstChildOfClass("SurfaceAppearance")
--                     if surfaceAppearance then
--                         surfaceAppearance.Transparency = characterEffects.transparencyValue
--                     end
--                 end
--             end
--         end
--     end
-- end

-- -- Function to apply material
-- local function applyMaterial()
--     if not character then return end
    
--     for _, obj in ipairs(character:GetDescendants()) do
--         -- Include Head but handle accessories carefully
--         if (obj:IsA("BasePart") or obj:IsA("MeshPart") or obj:IsA("UnionOperation")) and obj.Parent and 
--            obj.Name ~= "HumanoidRootPart" then
--             -- Check if it's an accessory part
--             local isAccessory = obj.Parent and obj.Parent:IsA("Accessory")
            
--             -- Apply material to all parts including head, but be careful with accessories
--             if not isAccessory or obj.Name == "Handle" then -- Only apply to accessory handles, not other accessory parts
--                 obj.Material = Enum.Material[characterEffects.selectedMaterial]
--             end
--         end
--     end
    
--     local arms = workspace.Camera:FindFirstChild("Arms")
--     if arms then
--         for _, v in ipairs(arms:GetDescendants()) do
--             if (v:IsA("MeshPart") or v:IsA("BasePart") or v:IsA("UnionOperation")) and v.Parent then
--                 v.Material = Enum.Material[characterEffects.selectedMaterial]
--             end
--         end
--     end
-- end

-- -- Function to apply transparency
-- local function applyTransparency()
--     if not character then return end
    
--     for _, obj in ipairs(character:GetDescendants()) do
--         if (obj:IsA("BasePart") or obj:IsA("MeshPart") or obj:IsA("UnionOperation")) and obj.Name ~= "HumanoidRootPart" and obj.Parent then
--             -- Check if it's an accessory part
--             local isAccessory = obj.Parent and obj.Parent:IsA("Accessory")
            
--             -- Apply transparency but handle accessories carefully (some accessories don't work well with transparency)
--             if not isAccessory then
--                 -- Apply to body parts including head
--                 obj.Transparency = characterEffects.transparencyValue
--                 local surfaceAppearance = obj:FindFirstChildOfClass("SurfaceAppearance")
--                 if surfaceAppearance then
--                     surfaceAppearance.Transparency = characterEffects.transparencyValue
--                 end
--             else
--                 -- For accessories, only apply to handle and use reduced transparency to avoid issues
--                 if obj.Name == "Handle" then
--                     local reducedTransparency = math.min(characterEffects.transparencyValue * 0.7, 0.8) -- Limit accessory transparency
--                     obj.Transparency = reducedTransparency
--                     local surfaceAppearance = obj:FindFirstChildOfClass("SurfaceAppearance")
--                     if surfaceAppearance then
--                         surfaceAppearance.Transparency = reducedTransparency
--                     end
--                 end
--             end
--         elseif (obj:IsA("Decal") or obj:IsA("Texture")) and obj.Parent then
--             -- Handle face separately - apply reduced transparency to face
--             if obj.Name == "face" then
--                 obj.Transparency = math.min(characterEffects.transparencyValue * 0.5, 0.7) -- Reduced face transparency
--             else
--                 obj.Transparency = characterEffects.transparencyValue
--             end
--         end
--     end
    
--     local arms = workspace.Camera:FindFirstChild("Arms")
--     if arms then
--         for _, v in ipairs(arms:GetDescendants()) do
--             if ((v:IsA("MeshPart") or v:IsA("BasePart") or v:IsA("UnionOperation") or v:IsA("Decal") or v:IsA("Texture")) and v.Parent) then
--                 v.Transparency = characterEffects.transparencyValue
--                 if (v:IsA("MeshPart") or v:IsA("BasePart") or v:IsA("UnionOperation")) then
--                     local surfaceAppearance = v:FindFirstChildOfClass("SurfaceAppearance")
--                     if surfaceAppearance then
--                         surfaceAppearance.Transparency = characterEffects.transparencyValue
--                     end
--                 end
--             end
--         end
--     end
-- end

-- -- Rainbow Toggle
-- seccharacter:AddToggle({
--     text = "Rainbow Character",
--     state = false,
--     tooltip = "Makes your character cycle through rainbow colors",
--     flag = "Toggle_Rainbow",
--     callback = function(state)
--         characterEffects.rainbowEnabled = state
        
--         if state then
--             if next(characterEffects.originalColors) == nil then
--                 storeOriginalColors()
--             end
            
--             if characterEffects.customColorEnabled then
--                 characterEffects.customColorEnabled = false
--             end
            
--             if characterEffects.rainbowConnection then
--                 characterEffects.rainbowConnection:Disconnect()
--             end
            
--             characterEffects.rainbowConnection = RunService.Heartbeat:Connect(applyRainbowEffect)
--         else
--             if characterEffects.rainbowConnection then
--                 characterEffects.rainbowConnection:Disconnect()
--                 characterEffects.rainbowConnection = nil
--             end
            
--             if not characterEffects.customColorEnabled then
--                 restoreOriginalColors()
--             end
--         end
--     end
-- })

-- -- Rainbow Speed Slider
-- seccharacter:AddSlider({
--     text = "Rainbow Speed",
--     tooltip = "Adjust the speed of the rainbow effect",
--     flag = "rainbowspeed",
--     min = 0.1,
--     max = 5,
--     increment = 0.1,
--     default = 1,
--     callback = function(v)
--         characterEffects.rainbowSpeed = v
--     end
-- })

-- seccharacter:AddSeparator({ text = "" })

-- -- Custom Color Toggle
-- seccharacter:AddToggle({
--     text = "Custom Color",
--     state = false,
--     tooltip = "Apply a custom color to your character",
--     flag = "Toggle_CustomColor",
--     callback = function(state)
--         characterEffects.customColorEnabled = state
        
--         if state then
--             if next(characterEffects.originalColors) == nil then
--                 storeOriginalColors()
--             end
            
--             if characterEffects.rainbowEnabled then
--                 characterEffects.rainbowEnabled = false
--                 if characterEffects.rainbowConnection then
--                     characterEffects.rainbowConnection:Disconnect()
--                     characterEffects.rainbowConnection = nil
--                 end
--             end
            
--             applyCustomColor()
--         else
--             if not characterEffects.rainbowEnabled then
--                 restoreOriginalColors()
--             end
--         end
--     end
-- })

-- -- Color Picker
-- seccharacter:AddColor({
--     text = "Character Color",
--     tooltip = "Choose a color for your character",
--     color = characterEffects.customColor,
--     trans = 0,
--     callback = function(color)
--         characterEffects.customColor = color
--         if characterEffects.customColorEnabled then
--             applyCustomColor()
--         end
--     end
-- })

-- seccharacter:AddSeparator({ text = "" })

-- -- Material Toggle
-- seccharacter:AddToggle({
--     text = "Custom Material",
--     state = false,
--     tooltip = "Apply a custom material to your character",
--     flag = "Toggle_Material",
--     callback = function(state)
--         characterEffects.materialEnabled = state
        
--         if state then
--             if next(characterEffects.originalColors) == nil then
--                 storeOriginalColors()
--             end
--             applyMaterial()
--         else
--             restoreOriginalColors()
--         end
--     end
-- })

-- -- Material Dropdown
-- seccharacter:AddList({
--     text = "Material Type",
--     tooltip = "Select character material",
--     selected = "ForceField",
--     multi = false,
--     max = 10,
--     values = {
--         "ForceField", "Neon", "Glass", "Plastic", "Wood", "Slate", "Concrete",
--         "CorrodedMetal", "DiamondPlate", "Foil", "Grass", "Ice", "Marble",
--         "Granite", "Brick", "Pebble", "Sand", "Fabric", "SmoothPlastic",
--         "Metal", "WoodPlanks", "Cobblestone"
--     },
--     callback = function(v)
--         characterEffects.selectedMaterial = v
--         if characterEffects.materialEnabled then
--             applyMaterial()
--         end
--     end
-- })

-- seccharacter:AddSeparator({ text = "" })

-- -- Transparency Toggle
-- seccharacter:AddToggle({
--     text = "Character Transparency",
--     state = false,
--     tooltip = "Make your character transparent",
--     flag = "Toggle_Transparency",
--     callback = function(state)
--         characterEffects.transparencyEnabled = state
        
--         if state then
--             if next(characterEffects.originalColors) == nil then
--                 storeOriginalColors()
--             end
--             applyTransparency()
--         else
--             restoreOriginalColors()
--         end
--     end
-- })

-- -- Transparency Slider
-- seccharacter:AddSlider({
--     text = "Transparency Level",
--     tooltip = "Adjust character transparency",
--     flag = "transparencylevel",
--     min = 0,
--     max = 0.95,
--     increment = 0.05,
--     default = 0.5,
--     callback = function(v)
--         characterEffects.transparencyValue = v
--         if characterEffects.transparencyEnabled then
--             applyTransparency()
--         end
--     end
-- })

-- -- Monitor for new Arms model
-- local function handleNewArms()
--     if characterEffects.rainbowEnabled or characterEffects.customColorEnabled or characterEffects.materialEnabled or characterEffects.transparencyEnabled then
--         storeOriginalColors()
--         if characterEffects.rainbowEnabled then
--             applyRainbowEffect()
--         elseif characterEffects.customColorEnabled then
--             applyCustomColor()
--         end
--         if characterEffects.materialEnabled then
--             applyMaterial()
--         end
--         if characterEffects.transparencyEnabled then
--             applyTransparency()
--         end
--     end
-- end

-- if workspace.Camera then
--     workspace.Camera.ChildAdded:Connect(function(child)
--         if child.Name == "Arms" then
--             task.wait(0.1)
--             handleNewArms()
--         end
--     end)

--     workspace.Camera.ChildRemoved:Connect(function(child)
--         if child.Name == "Arms" then
--             local newOriginalColors = {}
--             for obj, properties in pairs(characterEffects.originalColors) do
--                 if obj.Parent and obj.Parent ~= workspace.Camera:FindFirstChild("Arms") then
--                     newOriginalColors[obj] = properties
--                 end
--             end
--             characterEffects.originalColors = newOriginalColors
--             updateCharacterEffects()
--         end
--     end)
-- end

-- -- Update character effects when character respawns
-- local function updateCharacterEffects()
--     if character then
--         task.wait(0.5)
--         storeOriginalColors()
--         if characterEffects.rainbowEnabled then
--             if characterEffects.rainbowConnection then
--                 characterEffects.rainbowConnection:Disconnect()
--             end
--             characterEffects.rainbowConnection = RunService.Heartbeat:Connect(applyRainbowEffect)
--         elseif characterEffects.customColorEnabled then
--             applyCustomColor()
--         end
--         if characterEffects.materialEnabled then
--             applyMaterial()
--         end
--         if characterEffects.transparencyEnabled then
--             applyTransparency()
--         end
--     end
-- end

-- -- Connect to character added event
-- player.CharacterAdded:Connect(function(char)
--     character = char
--     humanoid = char:WaitForChild("Humanoid", 5)
--     characterEffects.originalColors = {}
--     characterEffects.zigzagCounter = 1
--     updateCharacterEffects()
-- end)

-- -- Initialize effects for existing character
-- if character then
--     updateCharacterEffects()
-- end

-- -- Cleanup function for character effects
-- local function cleanupCharacterEffects()
--     if characterEffects.rainbowConnection then
--         characterEffects.rainbowConnection:Disconnect()
--         characterEffects.rainbowConnection = nil
--     end
--     restoreOriginalColors()
--     characterEffects.rainbowEnabled = false
--     characterEffects.customColorEnabled = false
--     characterEffects.materialEnabled = false
--     characterEffects.transparencyEnabled = false
--     characterEffects.zigzagCounter = 1
-- end

-- -- Combine cleanup functions
-- local function masterCleanup()
--     cleanupStats()
--     cleanupCharacterEffects()
-- end

-- Store helper functions for external access
if secplayer then
    secplayer.DisableStats = cleanupStats
    secplayer.GetMovementMethod = function()
        return currentMovementMethod
    end
end

-- Store cleanup functions for external access
if _G.PlayerTab then
    _G.PlayerTab.CleanupStats = cleanupStats
    _G.PlayerTab.CleanupCharacterEffects = cleanupCharacterEffects
    _G.PlayerTab.MasterCleanup = masterCleanup
    _G.PlayerTab.GetMovementMethod = function()
        return currentMovementMethod
    end
end

-- Connect cleanup to player leaving or script ending
game.Players.PlayerRemoving:Connect(function(plr)
    if plr == player then
        masterCleanup()
    end
end)

-- Final initialization
if character then
    setupCharacter(character)
end

-- Ensure player section is marked as loaded
-- _G.CROW:SendNotification("Player section loaded successfully", 2)

-- Mark section as loaded for external scripts
_G.PlayerSectionLoaded = true
