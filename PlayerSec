-- Player Section
local secplayer = _G._G._G._G._G._G._G._G._G._G._G._G._G._G._G._G._G._G.PlayerTab:AddSection("Player", 1)
secplayer:AddSeparator({ enabled = true, text = "Player" })

-- Service References
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting") -- Added for FullBright

-- Player References
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local camera = workspace.CurrentCamera

-- Configuration values - Each feature has independent values
local speedValue = humanoid.WalkSpeed ~= 0 and humanoid.WalkSpeed or 16
local fovValue = camera.FieldOfView
local originalFov = camera.FieldOfView

-- Original lighting values storage
local originalLighting = {
    brightness = Lighting.Brightness,
    ambient = Lighting.Ambient,
    colorShift = Lighting.ColorShift_Top,
    fog = Lighting.FogEnd,
    shadowSoftness = Lighting.ShadowSoftness,
    time = Lighting.TimeOfDay,
    globalShadows = Lighting.GlobalShadows
}

-- Detect Jump Property
local jumpPropertyName = ""
local jumpValue, jumpMin, jumpMax, jumpMultiplier

if pcall(function() return humanoid.JumpPower end) then
    jumpPropertyName = "JumpPower"
    jumpValue = humanoid.JumpPower
    jumpMin = jumpValue
    jumpMax = jumpValue * 3
    jumpMultiplier = 1
elseif pcall(function() return humanoid.JumpHeight end) then
    jumpPropertyName = "JumpHeight"
    jumpValue = humanoid.JumpHeight
    jumpMin = jumpValue
    jumpMax = jumpValue * 2
    jumpMultiplier = 0.5
else
    jumpPropertyName = "JumpPower"
    jumpValue = 50
    jumpMin = jumpValue
    jumpMax = jumpValue * 3
    jumpMultiplier = 1
end

-- States
local states = {
    speedEnabled = false,
    jumpEnabled = false,
    fovEnabled = false,
    noclipEnabled = false,
    fullbrightEnabled = false
}

-- Movement State Tracking
local currentMovementMethod = "CFrame"
local connections = {}

-- Connection Management
local function trackConnection(connection, metadata)
    if metadata then
        table.insert(connections, {
            connection = connection,
            type = metadata
        })
    else
        table.insert(connections, connection)
    end
    return connection
end

-- Forward declarations for toggle functions
local toggleSpeed, toggleJump, toggleFOV, toggleNoclip, toggleFullBright

-- Character Setup (called when character spawns or respawns)
local function setupCharacter(char)
    if not char then return end
    
    -- Update character references
    character = char
    
    -- Wait for humanoid to be available
    local waitTime = 0
    local maxWaitTime = 5 -- maximum seconds to wait
    
    while not character:FindFirstChild("Humanoid") and waitTime < maxWaitTime do
        wait(0.1)
        waitTime = waitTime + 0.1
    end
    
    humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then
        warn("Failed to find Humanoid after character respawn")
        return
    end
    
    -- Set default values
    if humanoid.WalkSpeed == 0 then
        humanoid.WalkSpeed = 16
    end
    
    if jumpPropertyName ~= "" then
        -- Set jump property
        if pcall(function() return humanoid[jumpPropertyName] end) then
            humanoid[jumpPropertyName] = states.jumpEnabled and jumpValue or jumpMin
        end
    end
    
    -- Reapply active states with a slight delay to ensure properties exist
    spawn(function()
        wait(0.2) -- Small delay to ensure character is fully loaded
        if states.speedEnabled then toggleSpeed(true) end
        if states.jumpEnabled then toggleJump(true) end
        if states.noclipEnabled then toggleNoclip(true) end
    end)
end

-- Movement Methods
local movementMethods = {
    ["CFrame"] = function()
        if not character or not character:FindFirstChild("Humanoid") then return end
        local humanoid = character:FindFirstChild("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return end
        
        local moveDirection = humanoid.MoveDirection
        if moveDirection.Magnitude > 0.1 then
            local normalizedDir = moveDirection.Unit
            local deltaTime = RunService.Heartbeat:Wait()
            local stepSize = speedValue * deltaTime * 0.85
            
            rootPart.CFrame = rootPart.CFrame + (normalizedDir * stepSize)
            rootPart.Velocity = Vector3.new(
                rootPart.Velocity.X * 0.7,
                rootPart.Velocity.Y,
                rootPart.Velocity.Z * 0.7
            )
        end
        
        -- Apply jump enhancement for CFrame method
        if states.jumpEnabled and humanoid:GetState() == Enum.HumanoidStateType.Jumping then
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                -- Apply extra upward velocity for jumping
                local jumpVelocity = rootPart.Velocity + Vector3.new(0, jumpValue * 0.5, 0)
                rootPart.Velocity = jumpVelocity
            end
        end
    end,
    
    ["Normal"] = function()
        -- Normal mode continuously sets properties to ensure they never change
        if not character or not character:FindFirstChild("Humanoid") then return end
        local humanoid = character:FindFirstChild("Humanoid")
        
        -- Always maintain the current walkspeed regardless of external changes
        if states.speedEnabled then
            humanoid.WalkSpeed = speedValue
        end
        
        -- Always maintain the current jump property regardless of external changes
        if states.jumpEnabled and jumpPropertyName ~= "" then
            if pcall(function() return humanoid[jumpPropertyName] end) then
                humanoid[jumpPropertyName] = jumpValue
            end
        end
    end,
    
    ["Velocity"] = function()
        if not character or not character:FindFirstChild("Humanoid") then return end
        local humanoid = character:FindFirstChild("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return end
        
        local moveDirection = humanoid.MoveDirection
        if moveDirection.Magnitude > 0.1 then
            local normalizedDir = moveDirection.Unit
            
            -- Apply velocity-based movement
            rootPart.Velocity = Vector3.new(
                normalizedDir.X * speedValue * 1.2,
                rootPart.Velocity.Y,
                normalizedDir.Z * speedValue * 1.2
            )
        end
        
        -- Apply jump enhancement for Velocity method
        if states.jumpEnabled and humanoid:GetState() == Enum.HumanoidStateType.Jumping then
            rootPart.Velocity = Vector3.new(
                rootPart.Velocity.X,
                jumpValue * 1.2,
                rootPart.Velocity.Z
            )
        end
    end,
    
    ["BodyVelocity"] = function()
        if not character or not character:FindFirstChild("Humanoid") then return end
        local humanoid = character:FindFirstChild("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return end
        
        -- Find or create BodyVelocity instance
        local bodyVelocity = rootPart:FindFirstChild("MovementBodyVelocity")
        if not bodyVelocity then
            bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.Name = "MovementBodyVelocity"
            bodyVelocity.MaxForce = Vector3.new(100000, 0, 100000)
            bodyVelocity.P = 4000
            bodyVelocity.Parent = rootPart
        end
        
        local moveDirection = humanoid.MoveDirection
        if moveDirection.Magnitude > 0.1 then
            local normalizedDir = moveDirection.Unit
            bodyVelocity.Velocity = Vector3.new(
                normalizedDir.X * speedValue * 1.5,
                0,
                normalizedDir.Z * speedValue * 1.5
            )
        else
            bodyVelocity.Velocity = Vector3.new(0, 0, 0)
        end
        
        -- Apply jump enhancement for BodyVelocity method
        if states.jumpEnabled and humanoid:GetState() == Enum.HumanoidStateType.Jumping then
            -- Find or create BodyVelocity for jumping
            local jumpVelocity = rootPart:FindFirstChild("JumpBodyVelocity")
            if not jumpVelocity then
                jumpVelocity = Instance.new("BodyVelocity")
                jumpVelocity.Name = "JumpBodyVelocity"
                jumpVelocity.MaxForce = Vector3.new(0, 100000, 0)
                jumpVelocity.P = 4000
                jumpVelocity.Parent = rootPart
            end
            
            -- Apply jump force
            jumpVelocity.Velocity = Vector3.new(0, jumpValue * 2, 0)
            
            -- Remove jump force after a short delay
            spawn(function()
                wait(0.2)
                if jumpVelocity and jumpVelocity.Parent then
                    jumpVelocity:Destroy()
                end
            end)
        end
    end,
    
    ["Impulse"] = function()
        if not character or not character:FindFirstChild("Humanoid") then return end
        local humanoid = character:FindFirstChild("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return end
        
        local moveDirection = humanoid.MoveDirection
        if moveDirection.Magnitude > 0.1 then
            local normalizedDir = moveDirection.Unit
            local deltaTime = RunService.Heartbeat:Wait()
            local impulseForce = normalizedDir * speedValue * deltaTime * 20
            
            -- Apply impulse force 
            rootPart:ApplyImpulse(impulseForce)
        end
        
        -- Apply jump impulse
        if states.jumpEnabled and humanoid:GetState() == Enum.HumanoidStateType.Jumping then
            rootPart:ApplyImpulse(Vector3.new(0, jumpValue * 15, 0))
        end
    end
}

-- Function to clean up movement method effects
local function cleanupMovementMethod(methodName)
    if not character then return end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    
    -- Clean up BodyVelocity instances if they exist
    if methodName == "BodyVelocity" or methodName == "all" then
        local bv = rootPart:FindFirstChild("MovementBodyVelocity")
        if bv then bv:Destroy() end
        
        local jumpBV = rootPart:FindFirstChild("JumpBodyVelocity")
        if jumpBV then jumpBV:Destroy() end
    end
end

-- FOV watcher - ensures FOV is always at the correct value
local function watchFOV()
    -- Set up FOV watcher
    trackConnection(camera:GetPropertyChangedSignal("FieldOfView"):Connect(function()
        if states.fovEnabled and camera.FieldOfView ~= fovValue then
            camera.FieldOfView = fovValue
        end
    end), "fov_watcher")
end

-- Continuous property enforcement
local function enforceProperties()
    -- Check if character exists
    if not workspace:FindFirstChild(player.Name) then
        -- Character doesn't exist (player died), wait for respawn
        return
    end
    
    -- Re-get character and humanoid references if they don't exist
    if not character or not character.Parent then
        character = workspace:FindFirstChild(player.Name)
        if not character then return end
    end
    
    if not character:FindFirstChild("Humanoid") then return end
    local humanoid = character:FindFirstChild("Humanoid")
    
    -- FOV enforcement - Always force FOV to be the slider value when enabled
    if states.fovEnabled and camera.FieldOfView ~= fovValue then
        camera.FieldOfView = fovValue
    end
    
    -- Noclip enforcement
    if states.noclipEnabled then
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end
    
    -- Jump enforcement
    if states.jumpEnabled and jumpPropertyName ~= "" then
        if pcall(function() return humanoid[jumpPropertyName] end) then
            if humanoid[jumpPropertyName] ~= jumpValue then
                humanoid[jumpPropertyName] = jumpValue
            end
        end
    end
    
    -- Speed enforcement for Normal method
    if currentMovementMethod == "Normal" and states.speedEnabled then
        if humanoid.WalkSpeed ~= speedValue then
            humanoid.WalkSpeed = speedValue
        end
    end
    
    -- FullBright enforcement
    if states.fullbrightEnabled then
        Lighting.Brightness = 2
        Lighting.ClockTime = 14
        Lighting.FogEnd = 100000
        Lighting.GlobalShadows = false
        Lighting.Ambient = Color3.fromRGB(178, 178, 178)
    end
end

-- Movement Controls
local function toggleMovement(state)
    states.speedEnabled = state
    
    -- Clean up previous movement connections
    for i = #connections, 1, -1 do
        local conn = connections[i]
        if type(conn) == "table" and conn.type == "movement" then
            conn.connection:Disconnect()
            table.remove(connections, i)
        end
    end
    
    -- Clean up any physics objects from previous methods
    cleanupMovementMethod("all")
    
    if state then
        trackConnection(RunService.Heartbeat:Connect(movementMethods[currentMovementMethod]), "movement")
    else
        -- Restore default speed
        if character and character:FindFirstChild("Humanoid") then
            character:FindFirstChild("Humanoid").WalkSpeed = 16
        end
    end
end

toggleSpeed = function(state)
    states.speedEnabled = state
    toggleMovement(state)
    
    -- Immediately apply speed value
    if character and character:FindFirstChild("Humanoid") then
        character:FindFirstChild("Humanoid").WalkSpeed = state and speedValue or 16
    end
end

toggleJump = function(state)
    states.jumpEnabled = state
    
    if character and character:FindFirstChild("Humanoid") and jumpPropertyName ~= "" then
        if pcall(function() return character:FindFirstChild("Humanoid")[jumpPropertyName] end) then
            character:FindFirstChild("Humanoid")[jumpPropertyName] = state and jumpValue or jumpMin
        end
    end
end

toggleFOV = function(state)
    states.fovEnabled = state
    
    -- Immediately apply FOV value
    if state then
        camera.FieldOfView = fovValue
    else
        camera.FieldOfView = originalFov
    end
    
    -- Set up FOV watcher if not already set
    watchFOV()
end

toggleNoclip = function(state)
    states.noclipEnabled = state
    
    -- Clean up previous noclip connections
    for i = #connections, 1, -1 do
        local conn = connections[i]
        if type(conn) == "table" and conn.type == "noclip" then
            conn.connection:Disconnect()
            table.remove(connections, i)
        end
    end
    
    if state then
        trackConnection(RunService.Heartbeat:Connect(function()
            if not character or not character.Parent then return end
            
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end), "noclip")
    else
        -- Restore collision
        if character then
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                    part.CanCollide = true
                end
            end
        end
    end
end

-- New function for FullBright toggle
toggleFullBright = function(state)
    states.fullbrightEnabled = state
    
    -- Clean up previous fullbright connections
    for i = #connections, 1, -1 do
        local conn = connections[i]
        if type(conn) == "table" and conn.type == "fullbright" then
            conn.connection:Disconnect()
            table.remove(connections, i)
        end
    end
    
    if state then
        -- Store current lighting properties if not already stored
        originalLighting = {
            brightness = Lighting.Brightness,
            ambient = Lighting.Ambient,
            colorShift = Lighting.ColorShift_Top,
            fog = Lighting.FogEnd,
            shadowSoftness = Lighting.ShadowSoftness,
            time = Lighting.TimeOfDay,
            globalShadows = Lighting.GlobalShadows
        }
        
        -- Apply fullbright settings
        Lighting.Brightness = 2
        Lighting.ClockTime = 14
        Lighting.FogEnd = 100000
        Lighting.GlobalShadows = false
        Lighting.Ambient = Color3.fromRGB(178, 178, 178)
        
        -- Add connection to maintain fullbright
        trackConnection(RunService.Heartbeat:Connect(function()
            Lighting.Brightness = 2
            Lighting.ClockTime = 14
            Lighting.FogEnd = 100000
            Lighting.GlobalShadows = false
        end), "fullbright")
    else
        -- Restore original lighting settings
        Lighting.Brightness = originalLighting.brightness
        Lighting.Ambient = originalLighting.ambient
        Lighting.ColorShift_Top = originalLighting.colorShift
        Lighting.FogEnd = originalLighting.fog
        Lighting.ShadowSoftness = originalLighting.shadowSoftness
        Lighting.TimeOfDay = originalLighting.time
        Lighting.GlobalShadows = originalLighting.globalShadows
    end
end

local function updateMovementMethod(method)
    -- Clean up any physics objects from previous method
    cleanupMovementMethod(currentMovementMethod)
    
    currentMovementMethod = method
    
    if states.speedEnabled then
        toggleMovement(false)
        toggleMovement(true)
    end
    
    if movementDropdown then
        movementDropdown:Select(method)
    end
end

-- Connect to CharacterAdded event to handle respawns
trackConnection(player.CharacterAdded:Connect(setupCharacter))

-- Set up the continuous properties enforcement
trackConnection(RunService.RenderStepped:Connect(enforceProperties), "properties_enforcement")

-- Initial FOV watcher setup
watchFOV()

-- Cleanup Function
local function cleanupStats()
    for i = #connections, 1, -1 do
        local conn = connections[i]
        if type(conn) == "table" and conn.connection then
            conn.connection:Disconnect()
        elseif type(conn) == "userdata" then
            conn:Disconnect()
        end
        table.remove(connections, i)
    end
    
    -- Clean up any physics objects
    cleanupMovementMethod("all")
    
    -- Reset to default values
    if character and character:FindFirstChild("Humanoid") then
        character:FindFirstChild("Humanoid").WalkSpeed = 16
        if jumpPropertyName ~= "" then
            if pcall(function() return character:FindFirstChild("Humanoid")[jumpPropertyName] end) then
                character:FindFirstChild("Humanoid")[jumpPropertyName] = jumpMin
            end
        end
    end
    
    camera.FieldOfView = originalFov  -- Reset to original FOV
    
    -- Reset lighting
    if states.fullbrightEnabled then
        toggleFullBright(false)
    end
    
    -- Reset all states
    states.speedEnabled = false
    states.jumpEnabled = false
    states.fovEnabled = false
    states.noclipEnabled = false
    states.fullbrightEnabled = false
end
-- UI ELEMENTS

-- Movement Method Dropdown
local movementDropdown = secplayer:AddList({
    enabled = true,
    text = "Movement Method",
    tooltip = "Select player movement method",
    selected = "CFrame",
    multi = false,
    open = false,
    max = 5, -- Increased for more methods
    values = { "CFrame", "Normal", "Velocity", "BodyVelocity", "Impulse" }, -- Added new methods
    risky = false,
    callback = function(v)
        updateMovementMethod(v)
    end
})

-- Speed Controls
local speedSlider = secplayer:AddSlider({
    enabled = true,
    text = "WalkSpeed",
    tooltip = "Adjust player movement speed",
    flag = "walkspeed",
    min = 16,
    max = 150,
    increment = 1,
    callback = function(v)
        speedValue = v
        -- Force update speed if enabled, regardless of method
        if states.speedEnabled and character and character:FindFirstChild("Humanoid") then
            if currentMovementMethod == "Normal" then
                character:FindFirstChild("Humanoid").WalkSpeed = speedValue
            end
            -- In other modes, it will use the updated speedValue automatically
        end
    end
})

-- Speed Toggle with Keybind
secplayer:AddToggle({
    text = "Speed",
    state = false,
    risky = true,
    tooltip = "Toggle custom movement speed",
    flag = "Toggle_Speed",
    callback = function(state)
        toggleSpeed(state)
    end
}):AddBind({
    enabled = true,
    text = "Speed Key",
    tooltip = "Hotkey to toggle speed",
    mode = "toggle",
    bind = "None",
    state = false,
    nomouse = false,
    risky = true,
    noindicator = false,
    callback = function(v)
        toggleSpeed(v)
    end
})

-- Jump Controls
local jumpSlider = secplayer:AddSlider({
    enabled = true,
    text = jumpPropertyName,
    tooltip = "Adjust jump height/power",
    flag = "jumpvalue",
    min = jumpMin,
    max = jumpMax,
    increment = jumpMultiplier,
    callback = function(v)
        jumpValue = v
        if states.jumpEnabled and character and character:FindFirstChild("Humanoid") and jumpPropertyName ~= "" then
            if pcall(function() return character:FindFirstChild("Humanoid")[jumpPropertyName] end) then
                character:FindFirstChild("Humanoid")[jumpPropertyName] = jumpValue
            end
        end
    end
})

-- Jump Toggle with Keybind
secplayer:AddToggle({
    text = "Jump",
    state = false,
    risky = true,
    tooltip = "Toggle custom jump height",
    flag = "Toggle_Jump",
    callback = function(state)
        toggleJump(state)
    end
}):AddBind({
    enabled = true,
    text = "Jump Key",
    tooltip = "Hotkey to toggle jump",
    mode = "toggle",
    bind = "None",
    state = false,
    nomouse = false,
    risky = true,
    noindicator = false,
    callback = function(v)
        toggleJump(v)
    end
})

secplayer:AddSeparator({ enabled = true, text = "" })

-- Noclip Toggle and Keybind
secplayer:AddToggle({
    text = "Noclip",
    state = false,
    risky = true,
    tooltip = "Toggle noclip mode",
    flag = "Toggle_Noclip",
    callback = function(state)
        toggleNoclip(state)
    end
}):AddBind({
    enabled = true,
    text = "Noclip Key",
    tooltip = "Hotkey to toggle noclip mode",
    mode = "toggle",
    bind = "None",
    state = false,
    nomouse = false,
    risky = true,
    noindicator = false,
    callback = function(v)
        toggleNoclip(v)
    end
})

-- FOV Controls
secplayer:AddSeparator({ enabled = true, text = "Misc" })

local fovSlider = secplayer:AddSlider({
    enabled = true,
    text = "Field of View",
    tooltip = "Adjust camera field of view",
    flag = "fov",
    min = originalFov,
    max = 120,
    increment = 1,
    callback = function(v)
        fovValue = v
        if states.fovEnabled then
            -- Force update immediately
            camera.FieldOfView = v
        end
    end
})

-- FOV Toggle with Keybind
secplayer:AddToggle({
    text = "FOV",
    state = false,
    risky = false,
    tooltip = "Toggle custom field of view",
    flag = "Toggle_FOV",
    callback = function(state)
        toggleFOV(state)
    end
}):AddBind({
    enabled = true,
    text = "FOV Key",
    tooltip = "Hotkey to toggle FOV",
    mode = "toggle",
    bind = "None",
    state = false,
    nomouse = false,
    risky = false,
    noindicator = false,
    callback = function(v)
        toggleFOV(v)
    end
})

-- FullBright Toggle with Keybind (NEW)
secplayer:AddToggle({
    text = "FullBright",
    state = false,
    risky = false,
    tooltip = "Toggle full brightness lighting",
    flag = "Toggle_FullBright",
    callback = function(state)
        toggleFullBright(state)
    end
}):AddBind({
    enabled = true,
    text = "FullBright Key",
    tooltip = "Hotkey to toggle full brightness",
    mode = "toggle",
    bind = "None",
    state = false,
    nomouse = false,
    risky = false,
    noindicator = false,
    callback = function(v)
        toggleFullBright(v)
    end
})

-- Cleanup on unload
if _G._G._G._G._G._G._G._G._G._G._G._G._G._G._G._G._G._G._G.PlayerTab.AddCleanup then
    _G._G._G._G._G._G._G._G._G._G._G._G._G._G._G._G._G._G._G.PlayerTab:AddCleanup(cleanupStats)
end

-- Store helper functions
secplayer.DisableStats = cleanupStats
secplayer.GetMovementMethod = function()
    return currentMovementMethod
end








local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local character = player.Character
local humanoid = character and character:WaitForChild("Humanoid", 5)

-- Character Customization Section
local seccharacter = _G._G._G._G._G._G._G._G._G._G._G._G._G._G._G._G._G._G.PlayerTab:AddSection("Character Customization", 2)
seccharacter:AddSeparator({ enabled = true, text = "Character Effects" })

-- State for character effects
local characterEffects = {
    rainbowEnabled = false,
    customColorEnabled = false,
    customColor = Color3.fromRGB(255, 255, 255),
    rainbowSpeed = 1,
    rainbowConnection = nil,
    originalColors = {},
    materialEnabled = false,
    selectedMaterial = "ForceField",
    transparencyEnabled = false,
    transparencyValue = 0.5,
    zigzagCounter = 1
}

-- Zigzag function for rainbow effect
local function zigzag(X)
    return math.acos(math.cos(X * math.pi)) / math.pi
end

-- Function to store original properties
local function storeOriginalColors()
    characterEffects.originalColors = {}
    if character then
        for _, obj in ipairs(character:GetDescendants()) do
            if (obj:IsA("BasePart") or obj:IsA("MeshPart") or obj:IsA("UnionOperation")) and obj.Parent and obj.Name ~= "HumanoidRootPart" then
                characterEffects.originalColors[obj] = {
                    Color = obj.Color,
                    Material = obj.Material,
                    Transparency = obj.Transparency,
                    SurfaceAppearance = obj:FindFirstChildOfClass("SurfaceAppearance") and obj:FindFirstChildOfClass("SurfaceAppearance").Transparency or nil
                }
            elseif obj:IsA("Decal") or obj:IsA("Texture") then
                characterEffects.originalColors[obj] = {
                    Transparency = obj.Transparency
                }
            end
        end
    end
    -- Store properties for Arsenal viewmodel arms if they exist
    local arms = Workspace.Camera:FindFirstChild("Arms")
    if arms then
        for _, obj in ipairs(arms:GetDescendants()) do
            if (obj:IsA("MeshPart") or obj:IsA("BasePart") or obj:IsA("UnionOperation")) and obj.Parent then
                characterEffects.originalColors[obj] = {
                    Color = obj.Color,
                    Material = obj.Material,
                    Transparency = obj.Transparency,
                    SurfaceAppearance = obj:FindFirstChildOfClass("SurfaceAppearance") and obj:FindFirstChildOfClass("SurfaceAppearance").Transparency or nil
                }
            end
        end
    end
end

-- Function to restore original properties
local function restoreOriginalColors()
    for obj, properties in pairs(characterEffects.originalColors) do
        if obj and obj.Parent then
            if (obj:IsA("BasePart") or obj:IsA("MeshPart") or obj:IsA("UnionOperation")) and obj.Name ~= "HumanoidRootPart" then
                obj.Color = properties.Color
                if not characterEffects.materialEnabled then
                    obj.Material = properties.Material
                end
                if not characterEffects.transparencyEnabled then
                    obj.Transparency = properties.Transparency
                    local surfaceAppearance = obj:FindFirstChildOfClass("SurfaceAppearance")
                    if surfaceAppearance and properties.SurfaceAppearance then
                        surfaceAppearance.Transparency = properties.SurfaceAppearance
                    end
                end
            elseif obj:IsA("Decal") or obj:IsA("Texture") then
                if not characterEffects.transparencyEnabled then
                    obj.Transparency = properties.Transparency
                end
            end
        end
    end
end

-- Function to apply rainbow effect
local function applyRainbowEffect()
    if not character then return end
    
    local hue = (tick() * characterEffects.rainbowSpeed) % 1
    local color = Color3.fromHSV(hue, 1, 1)
    
    -- Character rainbow effect
    for _, obj in ipairs(character:GetDescendants()) do
        if (obj:IsA("BasePart") or obj:IsA("MeshPart") or obj:IsA("UnionOperation")) and obj.Parent and obj.Name ~= "HumanoidRootPart" then
            obj.Color = color
            if characterEffects.transparencyEnabled then
                local surfaceAppearance = obj:FindFirstChildOfClass("SurfaceAppearance")
                if surfaceAppearance then
                    surfaceAppearance.Transparency = characterEffects.transparencyValue
                end
            end
        end
    end
    
    -- Arsenal viewmodel arms rainbow effect
    local arms = Workspace.Camera:FindFirstChild("Arms")
    if arms then
        for _, v in ipairs(arms:GetDescendants()) do
            if (v:IsA("MeshPart") or v:IsA("BasePart") or v:IsA("UnionOperation")) and v.Parent then
                local zigzagHue = zigzag(characterEffects.zigzagCounter)
                v.Color = Color3.fromHSV(zigzagHue, 1, 1)
                if characterEffects.transparencyEnabled then
                    local surfaceAppearance = v:FindFirstChildOfClass("SurfaceAppearance")
                    if surfaceAppearance then
                        surfaceAppearance.Transparency = characterEffects.transparencyValue
                    end
                end
            end
        end
        characterEffects.zigzagCounter = characterEffects.zigzagCounter + (0.01 * characterEffects.rainbowSpeed)
    end
end

-- Function to apply custom color
local function applyCustomColor()
    if not character then return end
    
    for _, obj in ipairs(character:GetDescendants()) do
        if (obj:IsA("BasePart") or obj:IsA("MeshPart") or obj:IsA("UnionOperation")) and obj.Parent and obj.Name ~= "HumanoidRootPart" then
            obj.Color = characterEffects.customColor
            if characterEffects.transparencyEnabled then
                local surfaceAppearance = obj:FindFirstChildOfClass("SurfaceAppearance")
                if surfaceAppearance then
                    surfaceAppearance.Transparency = characterEffects.transparencyValue
                end
            end
        end
    end
    
    local arms = Workspace.Camera:FindFirstChild("Arms")
    if arms then
        for _, v in ipairs(arms:GetDescendants()) do
            if (v:IsA("MeshPart") or v:IsA("BasePart") or v:IsA("UnionOperation")) and v.Parent then
                v.Color = characterEffects.customColor
                if characterEffects.transparencyEnabled then
                    local surfaceAppearance = v:FindFirstChildOfClass("SurfaceAppearance")
                    if surfaceAppearance then
                        surfaceAppearance.Transparency = characterEffects.transparencyValue
                    end
                end
            end
        end
    end
end

-- Function to apply material
local function applyMaterial()
    if not character then return end
    
    for _, obj in ipairs(character:GetDescendants()) do
        if (obj:IsA("BasePart") or obj:IsA("MeshPart") or obj:IsA("UnionOperation")) and obj.Parent and obj.Name ~= "HumanoidRootPart" then
            obj.Material = Enum.Material[characterEffects.selectedMaterial]
        end
    end
    
    local arms = Workspace.Camera:FindFirstChild("Arms")
    if arms then
        for _, v in ipairs(arms:GetDescendants()) do
            if (v:IsA("MeshPart") or v:IsA("BasePart") or v:IsA("UnionOperation")) and v.Parent then
                v.Material = Enum.Material[characterEffects.selectedMaterial]
            end
        end
    end
end

-- Function to apply transparency
local function applyTransparency()
    if not character then return end
    
    for _, obj in ipairs(character:GetDescendants()) do
        if ((obj:IsA("BasePart") or obj:IsA("MeshPart") or obj:IsA("UnionOperation")) and obj.Name ~= "HumanoidRootPart" or obj:IsA("Decal") or obj:IsA("Texture")) and obj.Parent then
            obj.Transparency = characterEffects.transparencyValue
            if (obj:IsA("BasePart") or obj:IsA("MeshPart") or obj:IsA("UnionOperation")) then
                local surfaceAppearance = obj:FindFirstChildOfClass("SurfaceAppearance")
                if surfaceAppearance then
                    surfaceAppearance.Transparency = characterEffects.transparencyValue
                end
            end
        end
    end
    
    local arms = Workspace.Camera:FindFirstChild("Arms")
    if arms then
        for _, v in ipairs(arms:GetDescendants()) do
            if ((v:IsA("MeshPart") or v:IsA("BasePart") or v:IsA("UnionOperation") or v:IsA("Decal") or v:IsA("Texture")) and v.Parent) then
                v.Transparency = characterEffects.transparencyValue
                if (v:IsA("MeshPart") or v:IsA("BasePart") or v:IsA("UnionOperation")) then
                    local surfaceAppearance = v:FindFirstChildOfClass("SurfaceAppearance")
                    if surfaceAppearance then
                        surfaceAppearance.Transparency = characterEffects.transparencyValue
                    end
                end
            end
        end
    end
end

-- Rainbow Toggle
seccharacter:AddToggle({
    text = "Rainbow Character",
    state = false,
    risky = false,
    tooltip = "Makes your character cycle through rainbow colors",
    flag = "Toggle_Rainbow",
    callback = function(state)
        characterEffects.rainbowEnabled = state
        
        if state then
            if next(characterEffects.originalColors) == nil then
                storeOriginalColors()
            end
            
            if characterEffects.customColorEnabled then
                characterEffects.customColorEnabled = false
            end
            
            if characterEffects.rainbowConnection then
                characterEffects.rainbowConnection:Disconnect()
            end
            
            characterEffects.rainbowConnection = RunService.Heartbeat:Connect(applyRainbowEffect)
        else
            if characterEffects.rainbowConnection then
                characterEffects.rainbowConnection:Disconnect()
                characterEffects.rainbowConnection = nil
            end
            
            if not characterEffects.customColorEnabled then
                restoreOriginalColors()
            end
        end
    end
})

-- Rainbow Speed Slider
seccharacter:AddSlider({
    enabled = true,
    text = "Rainbow Speed",
    tooltip = "Adjust the speed of the rainbow effect",
    flag = "rainbowspeed",
    min = 0.1,
    max = 5,
    increment = 0.1,
    default = 1,
    callback = function(v)
        characterEffects.rainbowSpeed = v
    end
})

seccharacter:AddSeparator({ enabled = true, text = "" })

-- Custom Color Toggle
seccharacter:AddToggle({
    text = "Custom Color",
    state = false,
    risky = false,
    tooltip = "Apply a custom color to your character",
    flag = "Toggle_CustomColor",
    callback = function(state)
        characterEffects.customColorEnabled = state
        
        if state then
            if next(characterEffects.originalColors) == nil then
                storeOriginalColors()
            end
            
            if characterEffects.rainbowEnabled then
                characterEffects.rainbowEnabled = false
                if characterEffects.rainbowConnection then
                    characterEffects.rainbowConnection:Disconnect()
                    characterEffects.rainbowConnection = nil
                end
            end
            
            applyCustomColor()
        else
            if not characterEffects.rainbowEnabled then
                restoreOriginalColors()
            end
        end
    end
})

-- Color Picker
seccharacter:AddColor({
    enabled = true,
    text = "Character Color",
    tooltip = "Choose a color for your character",
    color = characterEffects.customColor,
    trans = 0,
    open = false,
    callback = function(color)
        characterEffects.customColor = color
        if characterEffects.customColorEnabled then
            applyCustomColor()
        end
    end
})

seccharacter:AddSeparator({ enabled = true, text = "" })

-- Material Toggle
seccharacter:AddToggle({
    text = "Custom Material",
    state = false,
    risky = false,
    tooltip = "Apply a custom material to your character",
    flag = "Toggle_Material",
    callback = function(state)
        characterEffects.materialEnabled = state
        
        if state then
            if next(characterEffects.originalColors) == nil then
                storeOriginalColors()
            end
            applyMaterial()
        else
            restoreOriginalColors()
        end
    end
})

-- Material Dropdown
seccharacter:AddList({
    enabled = true,
    text = "Material Type",
    tooltip = "Select character material",
    selected = "ForceField",
    multi = false,
    open = false,
    max = 10,
    values = {
        "ForceField", "Neon", "Glass", "Plastic", "Wood", "Slate", "Concrete",
        "CorrodedMetal", "DiamondPlate", "Foil", "Grass", "Ice", "Marble",
        "Granite", "Brick", "Pebble", "Sand", "Fabric", "SmoothPlastic",
        "Metal", "WoodPlanks", "Cobblestone"
    },
    risky = false,
    callback = function(v)
        characterEffects.selectedMaterial = v
        if characterEffects.materialEnabled then
            applyMaterial()
        end
    end
})

seccharacter:AddSeparator({ enabled = true, text = "" })

-- Transparency Toggle
seccharacter:AddToggle({
    text = "Character Transparency",
    state = false,
    risky = false,
    tooltip = "Make your character transparent",
    flag = "Toggle_Transparency",
    callback = function(state)
        characterEffects.transparencyEnabled = state
        
        if state then
            if next(characterEffects.originalColors) == nil then
                storeOriginalColors()
            end
            applyTransparency()
        else
            restoreOriginalColors()
        end
    end
})

-- Transparency Slider
seccharacter:AddSlider({
    enabled = true,
    text = "Transparency Level",
    tooltip = "Adjust character transparency",
    flag = "transparencylevel",
    min = 0,
    max = 0.95,
    increment = 0.05,
    default = 0.5,
    callback = function(v)
        characterEffects.transparencyValue = v
        if characterEffects.transparencyEnabled then
            applyTransparency()
        end
    end
})

-- Monitor for new Arms model
local function handleNewArms()
    if characterEffects.rainbowEnabled or characterEffects.customColorEnabled or characterEffects.materialEnabled or characterEffects.transparencyEnabled then
        storeOriginalColors()
        if characterEffects.rainbowEnabled then
            applyRainbowEffect()
        elseif characterEffects.customColorEnabled then
            applyCustomColor()
        end
        if characterEffects.materialEnabled then
            applyMaterial()
        end
        if characterEffects.transparencyEnabled then
            applyTransparency()
        end
    end
end

Workspace.Camera.ChildAdded:Connect(function(child)
    if child.Name == "Arms" then
        task.wait(0.1) -- Wait briefly for the model to fully load
        handleNewArms()
    end
end)

-- Monitor for Arms model removal
Workspace.Camera.ChildRemoved:Connect(function(child)
    if child.Name == "Arms" then
        -- Clear Arms-related original colors to prevent memory leaks
        local newOriginalColors = {}
        for obj, properties in pairs(characterEffects.originalColors) do
            if obj.Parent and obj.Parent ~= Workspace.Camera:FindFirstChild("Arms") then
                newOriginalColors[obj] = properties
            end
        end
        characterEffects.originalColors = newOriginalColors
        -- Reapply effects to character only
        updateCharacterEffects()
    end
end)

-- Update character effects when character respawns
local function updateCharacterEffects()
    if character then
        task.wait(0.5)
        storeOriginalColors()
        if characterEffects.rainbowEnabled then
            if characterEffects.rainbowConnection then
                characterEffects.rainbowConnection:Disconnect()
            end
            characterEffects.rainbowConnection = RunService.Heartbeat:Connect(applyRainbowEffect)
        elseif characterEffects.customColorEnabled then
            applyCustomColor()
        end
        if characterEffects.materialEnabled then
            applyMaterial()
        end
        if characterEffects.transparencyEnabled then
            applyTransparency()
        end
    end
end

-- Connect to character added event
player.CharacterAdded:Connect(function(char)
    character = char
    humanoid = char:WaitForChild("Humanoid", 5)
    characterEffects.originalColors = {}
    characterEffects.zigzagCounter = 1
    updateCharacterEffects()
end)

-- Initialize effects for existing character
if character then
    updateCharacterEffects()
end

-- Cleanup function
local function cleanupCharacterEffects()
    if characterEffects.rainbowConnection then
        characterEffects.rainbowConnection:Disconnect()
        characterEffects.rainbowConnection = nil
    end
    restoreOriginalColors()
    characterEffects.rainbowEnabled = false
    characterEffects.customColorEnabled = false
    characterEffects.materialEnabled = false
    characterEffects.transparencyEnabled = false
    characterEffects.zigzagCounter = 1
end

if seccharacter.AddCleanup then
    seccharacter:AddCleanup(cleanupCharacterEffects)
end
