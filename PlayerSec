-- Player Section
local secplayer = _G.PlayerTab:AddSection("Player", 1)
secplayer:AddSeparator({ text = "Player" })

-- Service References
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")
local TweenService = game:GetService("TweenService")

-- Player References
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character and character:WaitForChild("Humanoid", 5)
local camera = workspace.CurrentCamera

-- Validation checks
if not player then
    warn("LocalPlayer not found")
    return
end

if not camera then
    warn("Camera not found")
    return
end

-- Configuration values - Each feature has independent values
local speedValue = (humanoid and humanoid.WalkSpeed ~= 0) and humanoid.WalkSpeed or 16
local fovValue = camera.FieldOfView
local originalFov = camera.FieldOfView

-- Original lighting values storage
local originalLighting = {
    brightness = Lighting.Brightness,
    ambient = Lighting.Ambient,
    colorShift = Lighting.ColorShift_Top,
    fog = Lighting.FogEnd,
    shadowSoftness = Lighting.ShadowSoftness,
    time = Lighting.TimeOfDay,
    globalShadows = Lighting.GlobalShadows
}

-- Detect Jump Property
local jumpPropertyName = ""
local jumpValue, jumpMin, jumpMax, jumpMultiplier

local function detectJumpProperty()
    if not humanoid then return end
    
    if pcall(function() return humanoid.JumpPower end) then
        jumpPropertyName = "JumpPower"
        jumpValue = humanoid.JumpPower
        jumpMin = jumpValue
        jumpMax = jumpValue * 3
        jumpMultiplier = 1
    elseif pcall(function() return humanoid.JumpHeight end) then
        jumpPropertyName = "JumpHeight"
        jumpValue = humanoid.JumpHeight
        jumpMin = jumpValue
        jumpMax = jumpValue * 2
        jumpMultiplier = 0.5
    else
        jumpPropertyName = "JumpPower"
        jumpValue = 50
        jumpMin = jumpValue
        jumpMax = jumpValue * 3
        jumpMultiplier = 1
    end
end

detectJumpProperty()

-- States
local states = {
    speedEnabled = false,
    jumpEnabled = false,
    fovEnabled = false,
    noclipEnabled = false,
    fullbrightEnabled = false,
    flyEnabled = false
}

-- Movement State Tracking
local currentMovementMethod = "CFrame"
local connections = {}

-- Connection Management
local function trackConnection(connection, metadata)
    if metadata then
        table.insert(connections, {
            connection = connection,
            type = metadata
        })
    else
        table.insert(connections, connection)
    end
    return connection
end

-- Forward declarations for toggle functions
local toggleSpeed, toggleJump, toggleFOV, toggleFullBright, toggleNoclip, toggleFly

-- Character Setup (called when character spawns or respawns)
local function setupCharacter(char)
    if not char then return end
    
    -- Update character references
    character = char
    
    -- Wait for humanoid to be available with timeout
    local waitTime = 0
    local maxWaitTime = 5
    
    while not character:FindFirstChild("Humanoid") and waitTime < maxWaitTime do
        task.wait(0.1)
        waitTime = waitTime + 0.1
    end
    
    humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then
        warn("Failed to find Humanoid after character respawn")
        return
    end
    
    -- Set default values
    if humanoid.WalkSpeed == 0 then
        humanoid.WalkSpeed = 16
    end
    
    -- Re-detect jump property for new character
    detectJumpProperty()
    
    if jumpPropertyName ~= "" then
        -- Set jump property
        if pcall(function() return humanoid[jumpPropertyName] end) then
            humanoid[jumpPropertyName] = states.jumpEnabled and jumpValue or jumpMin
        end
    end
    
    -- Reapply active states with a slight delay to ensure properties exist
    task.spawn(function()
        task.wait(0.2)
        if states.speedEnabled then toggleSpeed(true) end
        if states.jumpEnabled then toggleJump(true) end
        if states.noclipEnabled then toggleNoclip(true) end
        if states.flyEnabled then toggleFly(true) end
    end)
end

-- Movement Methods
local movementMethods = {
    ["CFrame"] = function()
        if not character or not character:FindFirstChild("Humanoid") then return end
        local humanoid = character:FindFirstChild("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return end
        
        local moveDirection = humanoid.MoveDirection
        if moveDirection.Magnitude > 0.1 then
            local normalizedDir = moveDirection.Unit
            local deltaTime = RunService.Heartbeat:Wait()
            local stepSize = speedValue * deltaTime * 0.85
            
            rootPart.CFrame = rootPart.CFrame + (normalizedDir * stepSize)
            rootPart.Velocity = Vector3.new(
                rootPart.Velocity.X * 0.7,
                rootPart.Velocity.Y,
                rootPart.Velocity.Z * 0.7
            )
        end
        
        -- Apply jump enhancement for CFrame method
        if states.jumpEnabled and humanoid:GetState() == Enum.HumanoidStateType.Jumping then
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                local jumpVelocity = rootPart.Velocity + Vector3.new(0, jumpValue * 0.5, 0)
                rootPart.Velocity = jumpVelocity
            end
        end
    end,
    
    ["Normal"] = function()
        if not character or not character:FindFirstChild("Humanoid") then return end
        local humanoid = character:FindFirstChild("Humanoid")
        
        if states.speedEnabled then
            humanoid.WalkSpeed = speedValue
        end
        
        if states.jumpEnabled and jumpPropertyName ~= "" then
            if pcall(function() return humanoid[jumpPropertyName] end) then
                humanoid[jumpPropertyName] = jumpValue
            end
        end
    end,
    
    ["Velocity"] = function()
        if not character or not character:FindFirstChild("Humanoid") then return end
        local humanoid = character:FindFirstChild("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return end
        
        local moveDirection = humanoid.MoveDirection
        if moveDirection.Magnitude > 0.1 then
            local normalizedDir = moveDirection.Unit
            
            rootPart.Velocity = Vector3.new(
                normalizedDir.X * speedValue * 1.2,
                rootPart.Velocity.Y,
                normalizedDir.Z * speedValue * 1.2
            )
        end
        
        if states.jumpEnabled and humanoid:GetState() == Enum.HumanoidStateType.Jumping then
            rootPart.Velocity = Vector3.new(
                rootPart.Velocity.X,
                jumpValue * 1.2,
                rootPart.Velocity.Z
            )
        end
    end,
    
    ["BodyVelocity"] = function()
        if not character or not character:FindFirstChild("Humanoid") then return end
        local humanoid = character:FindFirstChild("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return end
        
        local bodyVelocity = rootPart:FindFirstChild("MovementBodyVelocity")
        if not bodyVelocity then
            bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.Name = "MovementBodyVelocity"
            bodyVelocity.MaxForce = Vector3.new(100000, 0, 100000)
            bodyVelocity.P = 4000
            bodyVelocity.Parent = rootPart
        end
        
        local moveDirection = humanoid.MoveDirection
        if moveDirection.Magnitude > 0.1 then
            local normalizedDir = moveDirection.Unit
            bodyVelocity.Velocity = Vector3.new(
                normalizedDir.X * speedValue * 1.5,
                0,
                normalizedDir.Z * speedValue * 1.5
            )
        else
            bodyVelocity.Velocity = Vector3.new(0, 0, 0)
        end
        
        if states.jumpEnabled and humanoid:GetState() == Enum.HumanoidStateType.Jumping then
            local jumpVelocity = rootPart:FindFirstChild("JumpBodyVelocity")
            if not jumpVelocity then
                jumpVelocity = Instance.new("BodyVelocity")
                jumpVelocity.Name = "JumpBodyVelocity"
                jumpVelocity.MaxForce = Vector3.new(0, 100000, 0)
                jumpVelocity.P = 4000
                jumpVelocity.Parent = rootPart
            end
            
            jumpVelocity.Velocity = Vector3.new(0, jumpValue * 2, 0)
            
            task.spawn(function()
                task.wait(0.2)
                if jumpVelocity and jumpVelocity.Parent then
                    jumpVelocity:Destroy()
                end
            end)
        end
    end,
    
    ["Impulse"] = function()
        if not character or not character:FindFirstChild("Humanoid") then return end
        local humanoid = character:FindFirstChild("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return end
        
        local moveDirection = humanoid.MoveDirection
        if moveDirection.Magnitude > 0.1 then
            local normalizedDir = moveDirection.Unit
            local deltaTime = RunService.Heartbeat:Wait()
            local impulseForce = normalizedDir * speedValue * deltaTime * 20
            
            rootPart:ApplyImpulse(impulseForce)
        end
        
        if states.jumpEnabled and humanoid:GetState() == Enum.HumanoidStateType.Jumping then
            rootPart:ApplyImpulse(Vector3.new(0, jumpValue * 15, 0))
        end
    end
}

-- Function to clean up movement method effects
local function cleanupMovementMethod(methodName)
    if not character then return end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    
    if methodName == "BodyVelocity" or methodName == "all" then
        local bv = rootPart:FindFirstChild("MovementBodyVelocity")
        if bv then bv:Destroy() end
        
        local jumpBV = rootPart:FindFirstChild("JumpBodyVelocity")
        if jumpBV then jumpBV:Destroy() end
    end
end

-- FOV watcher - ensures FOV is always at the correct value
local function watchFOV()
    if not camera then return end
    trackConnection(camera:GetPropertyChangedSignal("FieldOfView"):Connect(function()
        if states.fovEnabled and camera.FieldOfView ~= fovValue then
            camera.FieldOfView = fovValue
        end
    end), "fov_watcher")
end

RunService.Stepped:Connect(function()
        if not character or not character.Parent then return end
        
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") and part ~= character:FindFirstChild("HumanoidRootPart") then
                part.CanCollide = false
            end
        end
    end), "noclip")
    
    -- Also handle accessories and tools
    trackConnection(character.DescendantAdded:Connect(function(descendant)
        if states.noclipEnabled and descendant:IsA("BasePart") and descendant ~= character:FindFirstChild("HumanoidRootPart") then
            descendant.CanCollide = false
        end
    end), "noclip_descendant")
end

local function disableNoclip()
    if not character then return end
    
    -- Remove noclip connections
    for i = #connections, 1, -1 do
        local conn = connections[i]
        if type(conn) == "table" and (conn.type == "noclip" or conn.type == "noclip_descendant") then
            conn.connection:Disconnect()
            table.remove(connections, i)
        end
    end
    
    -- Restore collision
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") and part ~= character:FindFirstChild("HumanoidRootPart") then
            part.CanCollide = true
        end
    end
end

-- Optimized property enforcement with throttling
local lastPropertyUpdate = 0
local PROPERTY_UPDATE_INTERVAL = 0.05 -- Update every 0.05 seconds

local function enforceProperties()
    local now = tick()
    if now - lastPropertyUpdate < PROPERTY_UPDATE_INTERVAL then return end
    lastPropertyUpdate = now
    
    -- Check if character exists
    if not character or not character.Parent then
        character = player.Character
        if not character then return end
    end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return end
    
    -- FOV enforcement (only if different)
    if states.fovEnabled and camera and math.abs(camera.FieldOfView - fovValue) > 0.1 then
        camera.FieldOfView = fovValue
    end
    
    -- Jump enforcement (only if different)
    if states.jumpEnabled and jumpPropertyName ~= "" then
        local success, currentValue = pcall(function() return humanoid[jumpPropertyName] end)
        if success and math.abs(currentValue - jumpValue) > 0.1 then
            humanoid[jumpPropertyName] = jumpValue
        end
    end
    
    -- Speed enforcement for Normal method (only if different)
    if currentMovementMethod == "Normal" and states.speedEnabled then
        if math.abs(humanoid.WalkSpeed - speedValue) > 0.1 then
            humanoid.WalkSpeed = speedValue
        end
    end
    
    -- FullBright enforcement (reduced frequency)
    if states.fullbrightEnabled and now % 0.2 < PROPERTY_UPDATE_INTERVAL then
        if Lighting.Brightness ~= 2 then Lighting.Brightness = 2 end
        if Lighting.ClockTime ~= 14 then Lighting.ClockTime = 14 end
        if Lighting.FogEnd ~= 100000 then Lighting.FogEnd = 100000 end
        if Lighting.GlobalShadows ~= false then Lighting.GlobalShadows = false end
        if Lighting.Ambient ~= Color3.fromRGB(178, 178, 178) then
            Lighting.Ambient = Color3.fromRGB(178, 178, 178)
        end
    end
end

-- Movement Controls
local function toggleMovement(state)
    states.speedEnabled = state
    
    -- Clean up previous movement connections
    for i = #connections, 1, -1 do
        local conn = connections[i]
        if type(conn) == "table" and conn.type == "movement" then
            conn.connection:Disconnect()
            table.remove(connections, i)
        end
    end
    
    cleanupMovementMethod("all")
    
    if state then
        trackConnection(RunService.Heartbeat:Connect(movementMethods[currentMovementMethod]), "movement")
    else
        if character and character:FindFirstChild("Humanoid") then
            character:FindFirstChild("Humanoid").WalkSpeed = 16
        end
    end
end

toggleSpeed = function(state)
    states.speedEnabled = state
    toggleMovement(state)
    
    if character and character:FindFirstChild("Humanoid") then
        character:FindFirstChild("Humanoid").WalkSpeed = state and speedValue or 16
    end
end

toggleJump = function(state)
    states.jumpEnabled = state
    
    if character and character:FindFirstChild("Humanoid") and jumpPropertyName ~= "" then
        if pcall(function() return character:FindFirstChild("Humanoid")[jumpPropertyName] end) then
            character:FindFirstChild("Humanoid")[jumpPropertyName] = state and jumpValue or jumpMin
        end
    end
end

toggleFOV = function(state)
    states.fovEnabled = state
    
    if not camera then return end
    
    if state then
        camera.FieldOfView = fovValue
    else
        camera.FieldOfView = originalFov
    end
    
    watchFOV()
end

toggleNoclip = function(state)
    states.noclipEnabled = state
    
    if state then
        enableNoclip()
    else
        disableNoclip()
    end
end

toggleFly = function(state)
    states.flyEnabled = state
    
    if state then
        enableFly()
    else
        disableFly()
    end
end

toggleFullBright = function(state)
    states.fullbrightEnabled = state
    
    for i = #connections, 1, -1 do
        local conn = connections[i]
        if type(conn) == "table" and conn.type == "fullbright" then
            conn.connection:Disconnect()
            table.remove(connections, i)
        end
    end
    
    if state then
        originalLighting = {
            brightness = Lighting.Brightness,
            ambient = Lighting.Ambient,
            colorShift = Lighting.ColorShift_Top,
            fog = Lighting.FogEnd,
            shadowSoftness = Lighting.ShadowSoftness,
            time = Lighting.TimeOfDay,
            globalShadows = Lighting.GlobalShadows
        }
        
        Lighting.Brightness = 2
        Lighting.ClockTime = 14
        Lighting.FogEnd = 100000
        Lighting.GlobalShadows = false
        Lighting.Ambient = Color3.fromRGB(178, 178, 178)
        
        trackConnection(RunService.Heartbeat:Connect(function()
            Lighting.Brightness = 2
            Lighting.ClockTime = 14
            Lighting.FogEnd = 100000
            Lighting.GlobalShadows = false
        end), "fullbright")
    else
        Lighting.Brightness = originalLighting.brightness
        Lighting.Ambient = originalLighting.ambient
        Lighting.ColorShift_Top = originalLighting.colorShift
        Lighting.FogEnd = originalLighting.fog
        Lighting.ShadowSoftness = originalLighting.shadowSoftness
        Lighting.TimeOfDay = originalLighting.time
        Lighting.GlobalShadows = originalLighting.globalShadows
    end
end

local function updateMovementMethod(method)
    cleanupMovementMethod(currentMovementMethod)
    currentMovementMethod = method
    
    if states.speedEnabled then
        toggleMovement(false)
        toggleMovement(true)
    end
end

-- Connect to CharacterAdded event to handle respawns
trackConnection(player.CharacterAdded:Connect(setupCharacter))

-- Set up the continuous properties enforcement
trackConnection(RunService.RenderStepped:Connect(enforceProperties), "properties_enforcement")

-- Initial FOV watcher setup
watchFOV()

-- Cleanup Function
local function cleanupStats()
    for i = #connections, 1, -1 do
        local conn = connections[i]
        if type(conn) == "table" and conn.connection then
            conn.connection:Disconnect()
        elseif type(conn) == "userdata" then
            conn:Disconnect()
        end
        table.remove(connections, i)
    end
    
    cleanupMovementMethod("all")
    
    if character and character:FindFirstChild("Humanoid") then
        character:FindFirstChild("Humanoid").WalkSpeed = 16
        if jumpPropertyName ~= "" then
            if pcall(function() return character:FindFirstChild("Humanoid")[jumpPropertyName] end) then
                character:FindFirstChild("Humanoid")[jumpPropertyName] = jumpMin
            end
        end
    end
    
    if camera then
        camera.FieldOfView = originalFov
    end
    
    if states.fullbrightEnabled then
        toggleFullBright(false)
    end
    
    if states.noclipEnabled then
        disableNoclip()
    end
    
    if states.flyEnabled then
        disableFly()
    end
    
    states.speedEnabled = false
    states.jumpEnabled = false
    states.fovEnabled = false
    states.noclipEnabled = false
    states.fullbrightEnabled = false
    states.flyEnabled = false
end

-- UI ELEMENTS
local movementDropdown = secplayer:AddList({
    text = "Movement Method",
    tooltip = "Select player movement method",
    selected = "CFrame",
    multi = false,
    values = { "CFrame", "Normal", "Velocity", "BodyVelocity", "Impulse" },
    callback = function(v)
        updateMovementMethod(v)
    end
})

local speedSlider = secplayer:AddSlider({
    text = "WalkSpeed",
    tooltip = "Adjust player movement speed",
    flag = "walkspeed",
    min = 16,
    max = 150,
    increment = 1,
    default = speedValue,
    callback = function(v)
        speedValue = v
        if states.speedEnabled and character and character:FindFirstChild("Humanoid") then
            if currentMovementMethod == "Normal" then
                character:FindFirstChild("Humanoid").WalkSpeed = speedValue
            end
        end
    end
})

secplayer:AddToggle({
    text = "Speed",
    state = false,
    tooltip = "Toggle custom movement speed",
    flag = "Toggle_Speed",
    callback = function(state)
        toggleSpeed(state)
    end
}):AddBind({
    text = "Speed Key",
    tooltip = "Hotkey to toggle speed",
    mode = "toggle",
    bind = "None",
    callback = function(v)
        toggleSpeed(v)
    end
})

local jumpSlider = secplayer:AddSlider({
    text = jumpPropertyName,
    tooltip = "Adjust jump height/power",
    flag = "jumpvalue",
    min = jumpMin,
    max = jumpMax,
    increment = jumpMultiplier,
    default = jumpValue,
    callback = function(v)
        jumpValue = v
        if states.jumpEnabled and character and character:FindFirstChild("Humanoid") and jumpPropertyName ~= "" then
            if pcall(function() return character:FindFirstChild("Humanoid")[jumpPropertyName] end) then
                character:FindFirstChild("Humanoid")[jumpPropertyName] = jumpValue
            end
        end
    end
})

secplayer:AddToggle({
    text = "Jump",
    state = false,
    tooltip = "Toggle custom jump height",
    flag = "Toggle_Jump",
    callback = function(state)
        toggleJump(state)
    end
}):AddBind({
    text = "Jump Key",
    tooltip = "Hotkey to toggle jump",
    mode = "toggle",
    bind = "None",
    callback = function(v)
        toggleJump(v)
    end
})

secplayer:AddSeparator({ text = "" })

secplayer:AddToggle({
    text = "Noclip",
    state = false,
    tooltip = "Toggle noclip mode",
    flag = "Toggle_Noclip",
    callback = function(state)
        toggleNoclip(state)
    end
}):AddBind({
    text = "Noclip Key",
    tooltip = "Hotkey to toggle noclip mode",
    mode = "toggle",
    bind = "None",
    callback = function(v)
        toggleNoclip(v)
    end
})

-- Fly Speed Slider
local flySpeedSlider = secplayer:AddSlider({
    text = "Fly Speed",
    tooltip = "Adjust flying speed",
    flag = "flyspeed",
    min = 16,
    max = 200,
    increment = 1,
    default = 50,
    callback = function(v)
        flySpeed = v
    end
})

-- Fly Toggle with Keybind
secplayer:AddToggle({
    text = "Fly",
    state = false,
    tooltip = "Toggle fly mode - Use WASD to move in camera direction",
    flag = "Toggle_Fly",
    callback = function(state)
        toggleFly(state)
    end
}):AddBind({
    text = "Fly Key",
    tooltip = "Hotkey to toggle fly mode",
    mode = "toggle",
    bind = "F",
    callback = function(v)
        toggleFly(v)
    end
})

secplayer:AddSeparator({ text = "Misc" })

local fovSlider = secplayer:AddSlider({
    text = "Field of View",
    tooltip = "Adjust camera field of view",
    flag = "fov",
    min = originalFov,
    max = 120,
    increment = 1,
    default = fovValue,
    callback = function(v)
        fovValue = v
        if states.fovEnabled and camera then
            camera.FieldOfView = v
        end
    end
})

secplayer:AddToggle({
    text = "FOV",
    state = false,
    tooltip = "Toggle custom field of view",
    flag = "Toggle_FOV",
    callback = function(state)
        toggleFOV(state)
    end
}):AddBind({
    text = "FOV Key",
    tooltip = "Hotkey to toggle FOV",
    mode = "toggle",
    bind = "None",
    callback = function(v)
        toggleFOV(v)
    end
})

secplayer:AddToggle({
    text = "FullBright",
    state = false,
    tooltip = "Toggle full brightness lighting",
    flag = "Toggle_FullBright",
    callback = function(state)
        toggleFullBright(state)
    end
}):AddBind({
    text = "FullBright Key",
    tooltip = "Hotkey to toggle full brightness",
    mode = "toggle",
    bind = "None",
    callback = function(v)
        toggleFullBright(v)
    end
})

-- Character Customization Section
local seccharacter = _G.PlayerTab:AddSection("Character Customization", 2)
seccharacter:AddSeparator({ text = "Character Effects" })

-- State for character effects
local characterEffects = {
    rainbowEnabled = false,
    customColorEnabled = false,
    customColor = Color3.fromRGB(255, 255, 255),
    rainbowSpeed = 1,
    rainbowConnection = nil,
    originalColors = {},
    materialEnabled = false,
    selectedMaterial = "ForceField",
    transparencyEnabled = false,
    transparencyValue = 0.5,
    zigzagCounter = 1
}

-- Zigzag function for rainbow effect
local function zigzag(X)
    return math.acos(math.cos(X * math.pi)) / math.pi
end

-- Optimized character effects with caching and throttling
local characterPartsCache = {}
local lastPartsUpdate = 0
local lastRainbowUpdate = 0
local PARTS_CACHE_INTERVAL = 0.5 -- Update parts cache every 0.5 seconds
local RAINBOW_UPDATE_INTERVAL = 1/60 -- 60 FPS for smooth rainbow

-- Optimized function to get all character parts with caching
local function getCharacterParts()
    local now = tick()
    
    -- Use cache if still valid
    if now - lastPartsUpdate < PARTS_CACHE_INTERVAL and #characterPartsCache > 0 then
        return characterPartsCache
    end
    
    characterPartsCache = {}
    lastPartsUpdate = now
    
    if not character then return characterPartsCache end
    
    -- Get character parts efficiently
    for _, obj in pairs(character:GetDescendants()) do
        if (obj:IsA("BasePart") or obj:IsA("MeshPart") or obj:IsA("UnionOperation")) and 
           obj.Name ~= "HumanoidRootPart" and obj.Parent then
            table.insert(characterPartsCache, obj)
        end
    end
    
    -- Get arm parts from camera
    local arms = workspace.Camera:FindFirstChild("Arms")
    if arms then
        for _, obj in pairs(arms:GetDescendants()) do
            if (obj:IsA("BasePart") or obj:IsA("MeshPart") or obj:IsA("UnionOperation")) and obj.Parent then
                table.insert(characterPartsCache, obj)
            end
        end
    end
    
    return characterPartsCache
end

-- Optimized function to store original properties
local function storeOriginalColors()
    characterEffects.originalColors = {}
    local parts = getCharacterParts()
    
    for _, obj in pairs(parts) do
        if obj and obj.Parent then
            characterEffects.originalColors[obj] = {
                Color = obj.Color,
                Material = obj.Material,
                Transparency = obj.Transparency,
                Reflectance = obj.Reflectance
            }
            
            -- Store SurfaceAppearance transparency if it exists
            local surfaceApp = obj:FindFirstChildOfClass("SurfaceAppearance")
            if surfaceApp then
                characterEffects.originalColors[obj].SurfaceAppearanceTransparency = surfaceApp.Transparency
            end
        end
    end
    
    -- Store face transparency
    local head = character:FindFirstChild("Head")
    if head then
        local face = head:FindFirstChild("face")
        if face and face:IsA("Decal") then
            characterEffects.originalColors[face] = {
                Transparency = face.Transparency
            }
        end
    end
end

-- Heavily optimized rainbow effect with throttling
local function applyRainbowEffect()
    local now = tick()
    if now - lastRainbowUpdate < RAINBOW_UPDATE_INTERVAL then return end
    lastRainbowUpdate = now
    
    if not character then return end
    
    local time = now * characterEffects.rainbowSpeed
    local hue = (time % 1)
    local color = Color3.fromHSV(hue, 1, 1)
    
    local parts = getCharacterParts()
    for _, obj in pairs(parts) do
        if obj and obj.Parent then
            pcall(function()
                if obj.Color ~= color then
                    obj.Color = color
                end
                
                if characterEffects.transparencyEnabled and obj.Transparency ~= characterEffects.transparencyValue then
                    obj.Transparency = characterEffects.transparencyValue
                    local surfaceApp = obj:FindFirstChildOfClass("SurfaceAppearance")
                    if surfaceApp and surfaceApp.Transparency ~= characterEffects.transparencyValue then
                        surfaceApp.Transparency = characterEffects.transparencyValue
                    end
                end
                
                if characterEffects.materialEnabled then
                    local targetMaterial = Enum.Material[characterEffects.selectedMaterial]
                    if obj.Material ~= targetMaterial then
                        obj.Material = targetMaterial
                    end
                end
            end)
        end
    end
end

-- Optimized function to apply custom color
local function applyCustomColor()
    if not character then return end
    
    local parts = getCharacterParts()
    for _, obj in pairs(parts) do
        if obj and obj.Parent then
            pcall(function()
                if obj.Color ~= characterEffects.customColor then
                    obj.Color = characterEffects.customColor
                end
                
                if characterEffects.transparencyEnabled and obj.Transparency ~= characterEffects.transparencyValue then
                    obj.Transparency = characterEffects.transparencyValue
                    local surfaceApp = obj:FindFirstChildOfClass("SurfaceAppearance")
                    if surfaceApp and surfaceApp.Transparency ~= characterEffects.transparencyValue then
                        surfaceApp.Transparency = characterEffects.transparencyValue
                    end
                end
                
                if characterEffects.materialEnabled then
                    local targetMaterial = Enum.Material[characterEffects.selectedMaterial]
                    if obj.Material ~= targetMaterial then
                        obj.Material = targetMaterial
                    end
                end
            end)
        end
    end
end

-- Optimized function to apply material
local function applyMaterial()
    if not character then return end
    
    local targetMaterial = Enum.Material[characterEffects.selectedMaterial]
    local parts = getCharacterParts()
    for _, obj in pairs(parts) do
        if obj and obj.Parent then
            pcall(function()
                if obj.Material ~= targetMaterial then
                    obj.Material = targetMaterial
                end
            end)
        end
    end
end

-- Optimized function to apply transparency
local function applyTransparency()
    if not character then return end
    
    local parts = getCharacterParts()
    for _, obj in pairs(parts) do
        if obj and obj.Parent then
            pcall(function()
                if obj.Transparency ~= characterEffects.transparencyValue then
                    obj.Transparency = characterEffects.transparencyValue
                end
                
                local surfaceApp = obj:FindFirstChildOfClass("SurfaceAppearance")
                if surfaceApp and surfaceApp.Transparency ~= characterEffects.transparencyValue then
                    surfaceApp.Transparency = characterEffects.transparencyValue
                end
            end)
        end
    end
    
    -- Handle face transparency separately with reduced value
    local head = character:FindFirstChild("Head")
    if head then
        local face = head:FindFirstChild("face")
        if face and face:IsA("Decal") then
            pcall(function()
                local targetTransparency = math.min(characterEffects.transparencyValue * 0.7, 0.8)
                if face.Transparency ~= targetTransparency then
                    face.Transparency = targetTransparency
                end
            end)
        end
    end
endA("Decal") then
            characterEffects.originalColors[face] = {
                Transparency = face.Transparency
            }
        end
    end
end

-- Function to restore original properties
local function restoreOriginalColors()
    for obj, properties in pairs(characterEffects.originalColors) do
        if obj and obj.Parent then
            pcall(function()
                if obj:IsA("BasePart") or obj:IsA("MeshPart") or obj:IsA("UnionOperation") then
                    if not characterEffects.customColorEnabled and not characterEffects.rainbowEnabled then
                        obj.Color = properties.Color
                    end
                    if not characterEffects.materialEnabled then
                        obj.Material = properties.Material
                    end
                    if not characterEffects.transparencyEnabled then
                        obj.Transparency = properties.Transparency
                        obj.Reflectance = properties.Reflectance
                        
                        local surfaceApp = obj:FindFirstChildOfClass("SurfaceAppearance")
                        if surfaceApp and properties.SurfaceAppearanceTransparency then
                            surfaceApp.Transparency = properties.SurfaceAppearanceTransparency
                        end
                    end
                elseif obj:IsA("Decal") then
                    if not characterEffects.transparencyEnabled then
                        obj.Transparency = properties.Transparency
                    end
                end
            end)
        end
    end
end

-- Function to apply rainbow effect
local function applyRainbowEffect()
    if not character then return end
    
    local time = tick() * characterEffects.rainbowSpeed
    local hue = (time % 1)
    local color = Color3.fromHSV(hue, 1, 1)
    
    local parts = getCharacterParts()
    for _, obj in pairs(parts) do
        if obj and obj.Parent then
            pcall(function()
                obj.Color = color
                
                if characterEffects.transparencyEnabled then
                    obj.Transparency = characterEffects.transparencyValue
                    local surfaceApp = obj:FindFirstChildOfClass("SurfaceAppearance")
                    if surfaceApp then
                        surfaceApp.Transparency = characterEffects.transparencyValue
                    end
                end
                
                if characterEffects.materialEnabled then
                    obj.Material = Enum.Material[characterEffects.selectedMaterial]
                end
            end)
        end
    end
    
    characterEffects.zigzagCounter = characterEffects.zigzagCounter + (0.01 * characterEffects.rainbowSpeed)
end

-- Function to apply custom color
local function applyCustomColor()
    if not character then return end
    
    local parts = getCharacterParts()
    for _, obj in pairs(parts) do
        if obj and obj.Parent then
            pcall(function()
                obj.Color = characterEffects.customColor
                
                if characterEffects.transparencyEnabled then
                    obj.Transparency = characterEffects.transparencyValue
                    local surfaceApp = obj:FindFirstChildOfClass("SurfaceAppearance")
                    if surfaceApp then
                        surfaceApp.Transparency = characterEffects.transparencyValue
                    end
                end
                
                if characterEffects.materialEnabled then
                    obj.Material = Enum.Material[characterEffects.selectedMaterial]
                end
            end)
        end
    end
end

-- Function to apply material
local function applyMaterial()
    if not character then return end
    
    local parts = getCharacterParts()
    for _, obj in pairs(parts) do
        if obj and obj.Parent then
            pcall(function()
                obj.Material = Enum.Material[characterEffects.selectedMaterial]
            end)
        end
    end
end

-- Function to apply transparency
local function applyTransparency()
    if not character then return end
    
    local parts = getCharacterParts()
    for _, obj in pairs(parts) do
        if obj and obj.Parent then
            pcall(function()
                obj.Transparency = characterEffects.transparencyValue
                
                local surfaceApp = obj:FindFirstChildOfClass("SurfaceAppearance")
                if surfaceApp then
                    surfaceApp.Transparency = characterEffects.transparencyValue
                end
            end)
        end
    end
    
    -- Handle face transparency separately with reduced value
    local head = character:FindFirstChild("Head")
    if head then
        local face = head:FindFirstChild("face")
        if face and face:IsA("Decal") then
            pcall(function()
                face.Transparency = math.min(characterEffects.transparencyValue * 0.7, 0.8)
            end)
        end
    end
end

-- Function to update all character effects
local function updateCharacterEffects()
    if characterEffects.materialEnabled then
        applyMaterial()
    end
    
    if characterEffects.transparencyEnabled then
        applyTransparency()
    end
    
    if characterEffects.rainbowEnabled then
        applyRainbowEffect()
    elseif characterEffects.customColorEnabled then
        applyCustomColor()
    end
end

-- Rainbow Toggle
seccharacter:AddToggle({
    text = "Rainbow Character",
    state = false,
    tooltip = "Makes your character cycle through rainbow colors",
    flag = "Toggle_Rainbow",
    callback = function(state)
        characterEffects.rainbowEnabled = state
        
        if state then
            if next(characterEffects.originalColors) == nil then
                storeOriginalColors()
            end
            
            -- Disable custom color if rainbow is enabled
            if characterEffects.customColorEnabled then
                characterEffects.customColorEnabled = false
            end
            
            -- Clean up existing connection
            if characterEffects.rainbowConnection then
                characterEffects.rainbowConnection:Disconnect()
            end
            
            -- Start rainbow effect
            characterEffects.rainbowConnection = RunService.Heartbeat:Connect(applyRainbowEffect)
        else
            -- Stop rainbow effect
            if characterEffects.rainbowConnection then
                characterEffects.rainbowConnection:Disconnect()
                characterEffects.rainbowConnection = nil
            end
            
            -- Restore colors if no other color effect is active
            if not characterEffects.customColorEnabled then
                restoreOriginalColors()
            end
        end
    end
})

-- Rainbow Speed Slider
seccharacter:AddSlider({
    text = "Rainbow Speed",
    tooltip = "Adjust the speed of the rainbow effect",
    flag = "rainbowspeed",
    min = 0.1,
    max = 5,
    increment = 0.1,
    default = 1,
    callback = function(v)
        characterEffects.rainbowSpeed = v
    end
})

seccharacter:AddSeparator({ text = "" })

-- Custom Color Toggle
seccharacter:AddToggle({
    text = "Custom Color",
    state = false,
    tooltip = "Apply a custom color to your character",
    flag = "Toggle_CustomColor",
    callback = function(state)
        characterEffects.customColorEnabled = state
        
        if state then
            if next(characterEffects.originalColors) == nil then
                storeOriginalColors()
            end
            
            -- Disable rainbow if custom color is enabled
            if characterEffects.rainbowEnabled then
                characterEffects.rainbowEnabled = false
                if characterEffects.rainbowConnection then
                    characterEffects.rainbowConnection:Disconnect()
                    characterEffects.rainbowConnection = nil
                end
            end
            
            applyCustomColor()
        else
            -- Restore colors if rainbow is not active
            if not characterEffects.rainbowEnabled then
                restoreOriginalColors()
            end
        end
    end
})

-- Color Picker
seccharacter:AddColor({
    text = "Character Color",
    tooltip = "Choose a color for your character",
    color = characterEffects.customColor,
    trans = 0,
    callback = function(color)
        characterEffects.customColor = color
        if characterEffects.customColorEnabled then
            applyCustomColor()
        end
    end
})

seccharacter:AddSeparator({ text = "" })

-- Material Toggle
seccharacter:AddToggle({
    text = "Custom Material",
    state = false,
    tooltip = "Apply a custom material to your character",
    flag = "Toggle_Material",
    callback = function(state)
        characterEffects.materialEnabled = state
        
        if state then
            if next(characterEffects.originalColors) == nil then
                storeOriginalColors()
            end
            applyMaterial()
        else
            restoreOriginalColors()
        end
    end
})

-- Material Dropdown
seccharacter:AddList({
    text = "Material Type",
    tooltip = "Select character material",
    selected = "ForceField",
    multi = false,
    max = 10,
    values = {
        "ForceField", "Neon", "Glass", "Plastic", "Wood", "Slate", "Concrete",
        "CorrodedMetal", "DiamondPlate", "Foil", "Grass", "Ice", "Marble",
        "Granite", "Brick", "Pebble", "Sand", "Fabric", "SmoothPlastic",
        "Metal", "WoodPlanks", "Cobblestone"
    },
    callback = function(v)
        characterEffects.selectedMaterial = v
        if characterEffects.materialEnabled then
            applyMaterial()
        end
    end
})

seccharacter:AddSeparator({ text = "" })

-- Transparency Toggle
seccharacter:AddToggle({
    text = "Character Transparency",
    state = false,
    tooltip = "Make your character transparent",
    flag = "Toggle_Transparency",
    callback = function(state)
        characterEffects.transparencyEnabled = state
        
        if state then
            if next(characterEffects.originalColors) == nil then
                storeOriginalColors()
            end
            applyTransparency()
        else
            restoreOriginalColors()
        end
    end
})

-- Transparency Slider
seccharacter:AddSlider({
    text = "Transparency Level",
    tooltip = "Adjust character transparency",
    flag = "transparencylevel",
    min = 0,
    max = 0.95,
    increment = 0.05,
    default = 0.5,
    callback = function(v)
        characterEffects.transparencyValue = v
        if characterEffects.transparencyEnabled then
            applyTransparency()
        end
    end
})

-- Monitor for character changes
local function handleCharacterAdded(char)
    character = char
    humanoid = char:WaitForChild("Humanoid", 5)
    
    -- Reset character effects storage
    characterEffects.originalColors = {}
    characterEffects.zigzagCounter = 1
    
    -- Wait for character to fully load
    task.wait(1)
    
    -- Reapply character effects
    if characterEffects.rainbowEnabled or characterEffects.customColorEnabled or 
       characterEffects.materialEnabled or characterEffects.transparencyEnabled then
        storeOriginalColors()
        updateCharacterEffects()
        
        -- Restart rainbow connection if needed
        if characterEffects.rainbowEnabled then
            if characterEffects.rainbowConnection then
                characterEffects.rainbowConnection:Disconnect()
            end
            characterEffects.rainbowConnection = RunService.Heartbeat:Connect(applyRainbowEffect)
        end
    end
end

-- Monitor for new Arms model
local function handleArmsAdded()
    task.wait(0.1) -- Small delay to ensure arms are fully loaded
    if characterEffects.rainbowEnabled or characterEffects.customColorEnabled or 
       characterEffects.materialEnabled or characterEffects.transparencyEnabled then
        storeOriginalColors()
        updateCharacterEffects()
    end
end

-- Connect event handlers
if workspace.Camera then
    workspace.Camera.ChildAdded:Connect(function(child)
        if child.Name == "Arms" then
            handleArmsAdded()
        end
    end)
    
    workspace.Camera.ChildRemoved:Connect(function(child)
        if child.Name == "Arms" then
            -- Clean up arms references from originalColors
            local newOriginalColors = {}
            for obj, properties in pairs(characterEffects.originalColors) do
                if obj.Parent and not obj:IsDescendantOf(child) then
                    newOriginalColors[obj] = properties
                end
            end
            characterEffects.originalColors = newOriginalColors
        end
    end)
end

-- Connect to character added event
player.CharacterAdded:Connect(handleCharacterAdded)

-- Initialize effects for existing character
if character then
    handleCharacterAdded(character)
end

-- Cleanup function for character effects
local function cleanupCharacterEffects()
    if characterEffects.rainbowConnection then
        characterEffects.rainbowConnection:Disconnect()
        characterEffects.rainbowConnection = nil
    end
    
    restoreOriginalColors()
    
    characterEffects.rainbowEnabled = false
    characterEffects.customColorEnabled = false
    characterEffects.materialEnabled = false
    characterEffects.transparencyEnabled = false
    characterEffects.zigzagCounter = 1
    characterEffects.originalColors = {}
end

-- Master cleanup function
local function masterCleanup()
    cleanupStats()
    cleanupCharacterEffects()
end

-- Store helper functions for external access
if secplayer then
    secplayer.DisableStats = cleanupStats
    secplayer.GetMovementMethod = function()
        return currentMovementMethod
    end
end

-- Store cleanup functions for external access
if _G.PlayerTab then
    _G.PlayerTab.CleanupStats = cleanupStats
    _G.PlayerTab.CleanupCharacterEffects = cleanupCharacterEffects
    _G.PlayerTab.MasterCleanup = masterCleanup
    _G.PlayerTab.GetMovementMethod = function()
        return currentMovementMethod
    end
end

-- Connect cleanup to player leaving or script ending
game.Players.PlayerRemoving:Connect(function(plr)
    if plr == player then
        masterCleanup()
    end
end)

-- Final initialization
if character then
    setupCharacter(character)
end

-- Mark section as loaded for external scripts
_G.PlayerSectionLoaded = true
