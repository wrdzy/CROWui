-- Configuration Table
local Config = {
    -- Movement settings
    maxWalkSpeed = 150,
    walkSpeedIncrement = 1,
    jumpPowerMaxMultiplier = 3,
    jumpHeightMaxMultiplier = 2,
    jumpPowerIncrement = 1,
    jumpHeightIncrement = 0.5,
    
    -- FOV settings
    maxFOV = 120,
    fovIncrement = 1,
    
    -- Update intervals
    propertyUpdateInterval = 1/30, -- 30 FPS for property updates
    partsCacheInterval = 0.5, -- Cache refresh interval
    rainbowUpdateInterval = 1/60, -- Rainbow effect update rate
    

    
    -- Character customization settings
    characterEffects = {
        rainbowSpeedMin = 0.1,
        rainbowSpeedMax = 5,
        rainbowSpeedDefault = 1,
        rainbowSpeedIncrement = 0.1,
        transparencyMin = 0,
        transparencyMax = 0.95,
        transparencyDefault = 0.5,
        transparencyIncrement = 0.05,
        glowIntensityMin = 0.1,
        glowIntensityMax = 3,
        glowIntensityDefault = 1,
        glowIntensityIncrement = 0.1,
        outlineThicknessMin = 0.05,
        outlineThicknessMax = 0.5,
        outlineThicknessDefault = 0.1,
        outlineThicknessIncrement = 0.05,
        defaultCustomColor = Color3.fromRGB(255, 255, 255),
        defaultGlowColor = Color3.fromRGB(255, 255, 255),
        defaultOutlineColor = Color3.fromRGB(0, 0, 0),
        defaultMaterial = "ForceField",
        glowRange = 10,
        outlineTransparency = 0.2
    },
    
    -- Available materials for character customization
    materials = {
        "ForceField", "Neon", "Glass", "Plastic", "Wood", "Slate", "Concrete",
        "CorrodedMetal", "DiamondPlate", "Foil", "Grass", "Ice", "Marble",
        "Granite", "Brick", "Pebble", "Sand", "Fabric", "SmoothPlastic",
        "Metal", "WoodPlanks", "Cobblestone", "Asphalt", "LeafyGrass",
        "Rock", "Cardboard", "Pavement"
    }
}

-- Player Section
local secplayer = _G.PlayerTab:AddSection("Player", 1)
secplayer:AddSeparator({ text = "Player" })

-- Service References
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")
local TweenService = game:GetService("TweenService")

-- Player References
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character and character:WaitForChild("Humanoid", 5)
local camera = workspace.CurrentCamera

-- Validation checks
if not player then
    warn("LocalPlayer not found")
    return
end

if not camera then
    warn("Camera not found")
    return
end

if not humanoid then
    warn("Humanoid not found")
    return
end

-- Configuration values - Pulled from character
local speedValue = humanoid.WalkSpeed > 0 and humanoid.WalkSpeed or Config.maxWalkSpeed / 2
local fovValue = camera.FieldOfView
local originalFov = camera.FieldOfView

-- Original lighting values storage
local originalLighting = {
    brightness = Lighting.Brightness,
    ambient = Lighting.Ambient,
    colorShift = Lighting.ColorShift_Top,
    fog = Lighting.FogEnd,
    shadowSoftness = Lighting.ShadowSoftness,
    time = Lighting.TimeOfDay,
    globalShadows = Lighting.GlobalShadows,
    clockTime = Lighting.ClockTime
}

-- Detect Jump Property
local jumpPropertyName = ""
local jumpValue, jumpMin, jumpMax, jumpMultiplier
local originalJumpValue = 0

local function detectJumpProperty()
    if not humanoid then return end
    
    if pcall(function() return humanoid.JumpPower end) then
        jumpPropertyName = "JumpPower"
        jumpValue = humanoid.JumpPower > 0 and humanoid.JumpPower or Config.defaultJumpPower
        originalJumpValue = jumpValue
        jumpMin = jumpValue
        jumpMax = jumpValue * Config.jumpPowerMaxMultiplier
        jumpMultiplier = Config.jumpPowerIncrement
    elseif pcall(function() return humanoid.JumpHeight end) then
        jumpPropertyName = "JumpHeight"
        jumpValue = humanoid.JumpHeight > 0 and humanoid.JumpHeight or Config.defaultJumpHeight
        originalJumpValue = jumpValue
        jumpMin = jumpValue
        jumpMax = jumpValue * Config.jumpHeightMaxMultiplier
        jumpMultiplier = Config.jumpHeightIncrement
    else
        jumpPropertyName = "JumpPower"
        jumpValue = Config.defaultJumpPower
        originalJumpValue = jumpValue
        jumpMin = jumpValue
        jumpMax = jumpValue * Config.jumpPowerMaxMultiplier
        jumpMultiplier = Config.jumpPowerIncrement
    end
end

detectJumpProperty()

-- Store original values
local originalValues = {
    walkSpeed = speedValue,
    jumpValue = originalJumpValue,
    fov = originalFov
}

-- States
local states = {
    speedEnabled = false,
    jumpEnabled = false,
    fovEnabled = false,
    --noclipEnabled = false,
}

-- Movement State Tracking
local currentMovementMethod = "CFrame"
local connections = {}

-- Connection Management
local function trackConnection(connection, metadata)
    if metadata then
        table.insert(connections, {
            connection = connection,
            type = metadata
        })
    else
        table.insert(connections, connection)
    end
    return connection
end

local function cleanupConnections(connectionType)
    for i = #connections, 1, -1 do
        local conn = connections[i]
        if type(conn) == "table" then
            if not connectionType or conn.type == connectionType then
                if conn.connection and conn.connection.Connected then
                    conn.connection:Disconnect()
                end
                table.remove(connections, i)
            end
        elseif type(conn) == "userdata" and conn.Connected then
            conn:Disconnect()
            table.remove(connections, i)
        end
    end
end

-- Forward declarations for toggle functions
local toggleSpeed, toggleJump, toggleFOV--, toggleNoclip

-- Character Setup (called when character spawns or respawns)
local function setupCharacter(char)
    if not char then return end
    
    -- Update character references
    character = char
    
    -- Wait for humanoid to be available with timeout
    humanoid = char:WaitForChild("Humanoid", 5)
    
    if not humanoid then
        warn("Failed to find Humanoid after character respawn")
        return
    end
    
    -- Store original values for new character
    originalValues.walkSpeed = humanoid.WalkSpeed > 0 and humanoid.WalkSpeed or Config.maxWalkSpeed / 2
    speedValue = originalValues.walkSpeed
    
    -- Re-detect jump property for new character
    detectJumpProperty()
    originalValues.jumpValue = originalJumpValue
    
    -- Reapply active states with a slight delay to ensure properties exist
    task.spawn(function()
        task.wait(0.5)
        if states.speedEnabled then toggleSpeed(true) end
        if states.jumpEnabled then toggleJump(true) end
        --if states.noclipEnabled then toggleNoclip(true) end
    end)
end

-- Movement Methods
local movementMethods = {
    ["CFrame"] = function()
        if not character or not humanoid then return end
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return end
        
        local moveDirection = humanoid.MoveDirection
        if moveDirection.Magnitude > 0.1 then
            local normalizedDir = moveDirection.Unit
            local deltaTime = RunService.Heartbeat:Wait()
            local stepSize = speedValue * deltaTime * 0.85
            
            rootPart.CFrame = rootPart.CFrame + (normalizedDir * stepSize)
            rootPart.Velocity = Vector3.new(
                rootPart.Velocity.X * 0.7,
                rootPart.Velocity.Y,
                rootPart.Velocity.Z * 0.7
            )
        end
        
        -- Apply jump enhancement for CFrame method
        if states.jumpEnabled and humanoid:GetState() == Enum.HumanoidStateType.Jumping then
            rootPart.Velocity = rootPart.Velocity + Vector3.new(0, jumpValue * 0.5, 0)
        end
    end,
    
    ["Normal"] = function()
        if not character or not humanoid then return end
        
        if states.speedEnabled then
            humanoid.WalkSpeed = speedValue
        end
        
        if states.jumpEnabled and jumpPropertyName ~= "" then
            pcall(function()
                humanoid[jumpPropertyName] = jumpValue
            end)
        end
    end,
    
    ["Velocity"] = function()
        if not character or not humanoid then return end
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return end
        
        local moveDirection = humanoid.MoveDirection
        if moveDirection.Magnitude > 0.1 then
            local normalizedDir = moveDirection.Unit
            
            rootPart.Velocity = Vector3.new(
                normalizedDir.X * speedValue * 1.2,
                rootPart.Velocity.Y,
                normalizedDir.Z * speedValue * 1.2
            )
        end
        
        if states.jumpEnabled and humanoid:GetState() == Enum.HumanoidStateType.Jumping then
            rootPart.Velocity = Vector3.new(
                rootPart.Velocity.X,
                jumpValue * 1.2,
                rootPart.Velocity.Z
            )
        end
    end,
    
    ["BodyVelocity"] = function()
        if not character or not humanoid then return end
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return end
        
        local bodyVelocity = rootPart:FindFirstChild("MovementBodyVelocity")
        if not bodyVelocity then
            bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.Name = "MovementBodyVelocity"
            bodyVelocity.MaxForce = Vector3.new(100000, 0, 100000)
            bodyVelocity.P = 4000
            bodyVelocity.Parent = rootPart
        end
        
        local moveDirection = humanoid.MoveDirection
        if moveDirection.Magnitude > 0.1 then
            local normalizedDir = moveDirection.Unit
            bodyVelocity.Velocity = Vector3.new(
                normalizedDir.X * speedValue * 1.5,
                0,
                normalizedDir.Z * speedValue * 1.5
            )
        else
            bodyVelocity.Velocity = Vector3.new(0, 0, 0)
        end
        
        if states.jumpEnabled and humanoid:GetState() == Enum.HumanoidStateType.Jumping then
            local jumpVelocity = rootPart:FindFirstChild("JumpBodyVelocity")
            if not jumpVelocity then
                jumpVelocity = Instance.new("BodyVelocity")
                jumpVelocity.Name = "JumpBodyVelocity"
                jumpVelocity.MaxForce = Vector3.new(0, 100000, 0)
                jumpVelocity.P = 4000
                jumpVelocity.Parent = rootPart
            end
            
            jumpVelocity.Velocity = Vector3.new(0, jumpValue * 2, 0)
            
            task.spawn(function()
                task.wait(0.2)
                if jumpVelocity and jumpVelocity.Parent then
                    jumpVelocity:Destroy()
                end
            end)
        end
    end,
    
    ["Impulse"] = function()
        if not character or not humanoid then return end
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return end
        
        local moveDirection = humanoid.MoveDirection
        if moveDirection.Magnitude > 0.1 then
            local normalizedDir = moveDirection.Unit
            local deltaTime = RunService.Heartbeat:Wait()
            local impulseForce = normalizedDir * speedValue * deltaTime * 20
            
            -- Use AssemblyLinearVelocity for newer Roblox versions
            if rootPart.AssemblyLinearVelocity then
                rootPart.AssemblyLinearVelocity = rootPart.AssemblyLinearVelocity + impulseForce
            else
                rootPart.Velocity = rootPart.Velocity + impulseForce
            end
        end
        
        if states.jumpEnabled and humanoid:GetState() == Enum.HumanoidStateType.Jumping then
            if rootPart.AssemblyLinearVelocity then
                rootPart.AssemblyLinearVelocity = rootPart.AssemblyLinearVelocity + Vector3.new(0, jumpValue * 15, 0)
            else
                rootPart.Velocity = rootPart.Velocity + Vector3.new(0, jumpValue * 15, 0)
            end
        end
    end
}

-- Function to clean up movement method effects
local function cleanupMovementMethod(methodName)
    if not character then return end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    
    if methodName == "BodyVelocity" or methodName == "all" then
        local bv = rootPart:FindFirstChild("MovementBodyVelocity")
        if bv then bv:Destroy() end
        
        local jumpBV = rootPart:FindFirstChild("JumpBodyVelocity")
        if jumpBV then jumpBV:Destroy() end
    end
end

-- FOV watcher - ensures FOV is always at the correct value
local function watchFOV()
    if not camera then return end
    cleanupConnections("fov_watcher")
    trackConnection(camera:GetPropertyChangedSignal("FieldOfView"):Connect(function()
        if states.fovEnabled and camera.FieldOfView ~= fovValue then
            camera.FieldOfView = fovValue
        end
    end), "fov_watcher")
end

-- local function enableNoclip()
--     if not character then return end
    
--     cleanupConnections("noclip")
    
--     local connection = RunService.Stepped:Connect(function()
--         if not character or not character.Parent then return end
        
--         for _, part in pairs(character:GetDescendants()) do
--             if part:IsA("BasePart") and part ~= character:FindFirstChild("HumanoidRootPart") then
--                 part.CanCollide = false
--             end
--         end
--     end)
    
--     trackConnection(connection, "noclip")
    
--     -- Also handle accessories and tools
--     local descendantConnection = character.DescendantAdded:Connect(function(descendant)
--         if states.noclipEnabled and descendant:IsA("BasePart") and descendant ~= character:FindFirstChild("HumanoidRootPart") then
--             descendant.CanCollide = false
--         end
--     end)
    
--     trackConnection(descendantConnection, "noclip")
-- end

-- local function disableNoclip()
--     if not character then return end
    
--     -- Remove noclip connections
--     cleanupConnections("noclip")
    
--     -- Restore collision
--     for _, part in pairs(character:GetDescendants()) do
--         if part:IsA("BasePart") and part ~= character:FindFirstChild("HumanoidRootPart") then
--             part.CanCollide = true
--         end
--     end
-- end

-- Optimized property enforcement with throttling
local lastPropertyUpdate = 0

local function enforceProperties()
    local now = tick()
    if now - lastPropertyUpdate < Config.propertyUpdateInterval then return end
    lastPropertyUpdate = now
    
    -- Check if character exists
    if not character or not character.Parent then
        character = player.Character
        if not character then return end
        humanoid = character:FindFirstChildOfClass("Humanoid")
    end
    
    if not humanoid then return end
    
    -- FOV enforcement (only if different)
    if states.fovEnabled and camera and math.abs(camera.FieldOfView - fovValue) > 0.1 then
        camera.FieldOfView = fovValue
    end
    
    -- Jump enforcement (only if different)
    if states.jumpEnabled and jumpPropertyName ~= "" then
        local success, currentValue = pcall(function() return humanoid[jumpPropertyName] end)
        if success and math.abs(currentValue - jumpValue) > 0.1 then
            humanoid[jumpPropertyName] = jumpValue
        end
    end
    
    -- Speed enforcement for Normal method (only if different)
    if currentMovementMethod == "Normal" and states.speedEnabled then
        if math.abs(humanoid.WalkSpeed - speedValue) > 0.1 then
            humanoid.WalkSpeed = speedValue
        end
    end
end

-- Movement Controls
local function toggleMovement(state)
    states.speedEnabled = state
    
    -- Clean up previous movement connections
    cleanupConnections("movement")
    cleanupMovementMethod("all")
    
    if state then
        trackConnection(RunService.Heartbeat:Connect(movementMethods[currentMovementMethod]), "movement")
    else
        if humanoid then
            humanoid.WalkSpeed = originalValues.walkSpeed
        end
    end
end

toggleSpeed = function(state)
    states.speedEnabled = state
    toggleMovement(state)
    
    if humanoid then
        humanoid.WalkSpeed = state and speedValue or originalValues.walkSpeed
    end
end

toggleJump = function(state)
    states.jumpEnabled = state
    
    if humanoid and jumpPropertyName ~= "" then
        pcall(function()
            humanoid[jumpPropertyName] = state and jumpValue or originalValues.jumpValue
        end)
    end
end

toggleFOV = function(state)
    states.fovEnabled = state
    
    if not camera then return end
    
    if state then
        camera.FieldOfView = fovValue
        watchFOV()
    else
        camera.FieldOfView = originalValues.fov
        cleanupConnections("fov_watcher")
    end
end

-- toggleNoclip = function(state)
--     states.noclipEnabled = state
    
--     if state then
--         enableNoclip()
--     else
--         disableNoclip()
--     end
-- end


local function updateMovementMethod(method)
    cleanupMovementMethod(currentMovementMethod)
    currentMovementMethod = method
    
    if states.speedEnabled then
        toggleMovement(false)
        toggleMovement(true)
    end
end

-- Connect to CharacterAdded event to handle respawns
trackConnection(player.CharacterAdded:Connect(setupCharacter))

-- Set up the continuous properties enforcement
trackConnection(RunService.RenderStepped:Connect(enforceProperties), "properties_enforcement")

-- Initial FOV watcher setup
watchFOV()

-- Cleanup Function
local function cleanupStats()
    cleanupConnections()
    cleanupMovementMethod("all")
    
    if humanoid then
        humanoid.WalkSpeed = originalValues.walkSpeed
        if jumpPropertyName ~= "" then
            pcall(function()
                humanoid[jumpPropertyName] = originalValues.jumpValue
            end)
        end
    end
    
    if camera then
        camera.FieldOfView = originalValues.fov
    end
    
    -- if states.noclipEnabled then
    --     disableNoclip()
    -- end
    
    for key, _ in pairs(states) do
        states[key] = false
    end
end

-- UI ELEMENTS
local movementDropdown = secplayer:AddList({
    text = "Movement Method",
    tooltip = "Select player movement method",
    selected = "CFrame",
    multi = false,
    values = { "CFrame", "Normal", "Velocity", "BodyVelocity", "Impulse" },
    callback = function(v)
        updateMovementMethod(v)
    end
})

local speedSlider = secplayer:AddSlider({
    text = "WalkSpeed",
    tooltip = "Adjust player movement speed",
    flag = "walkspeed",
    min = originalValues.walkSpeed,
    max = Config.maxWalkSpeed,
    increment = Config.walkSpeedIncrement,
    default = speedValue,
    callback = function(v)
        speedValue = v
        if states.speedEnabled and humanoid then
            if currentMovementMethod == "Normal" then
                humanoid.WalkSpeed = speedValue
            end
        end
    end
})

secplayer:AddToggle({
    text = "Speed",
    state = false,
    tooltip = "Toggle custom movement speed",
    flag = "Toggle_Speed",
    callback = function(state)
        toggleSpeed(state)
    end
}):AddBind({
    text = "Speed Key",
    tooltip = "Hotkey to toggle speed",
    mode = "toggle",
    bind = "None",
    callback = function(v)
        toggleSpeed(v)
    end
})

local jumpSlider = secplayer:AddSlider({
    text = jumpPropertyName,
    tooltip = "Adjust jump height/power",
    flag = "jumpvalue",
    min = jumpMin,
    max = jumpMax,
    increment = jumpMultiplier,
    default = jumpValue,
    callback = function(v)
        jumpValue = v
        if states.jumpEnabled and humanoid and jumpPropertyName ~= "" then
            pcall(function()
                humanoid[jumpPropertyName] = jumpValue
            end)
        end
    end
})

secplayer:AddToggle({
    text = "Jump",
    state = false,
    tooltip = "Toggle custom jump height",
    flag = "Toggle_Jump",
    callback = function(state)
        toggleJump(state)
    end
}):AddBind({
    text = "Jump Key",
    tooltip = "Hotkey to toggle jump",
    mode = "toggle",
    bind = "None",
    callback = function(v)
        toggleJump(v)
    end
})

-- secplayer:AddSeparator({ text = "" })

-- secplayer:AddToggle({
--     text = "Noclip",
--     state = false,
--     tooltip = "Toggle noclip mode",
--     flag = "Toggle_Noclip",
--     callback = function(state)
--         toggleNoclip(state)
--     end
-- }):AddBind({
--     text = "Noclip Key",
--     tooltip = "Hotkey to toggle noclip mode",
--     mode = "toggle",
--     bind = "None",
--     callback = function(v)
--         toggleNoclip(v)
--     end
-- })

secplayer:AddSeparator({ text = "Misc" })

local fovSlider = secplayer:AddSlider({
    text = "Field of View",
    tooltip = "Adjust camera field of view",
    flag = "fov",
    min = originalFov,
    max = Config.maxFOV,
    increment = Config.fovIncrement,
    default = fovValue,
    callback = function(v)
        fovValue = v
        if states.fovEnabled and camera then
            camera.FieldOfView = v
        end
    end
})

secplayer:AddToggle({
    text = "FOV",
    state = false,
    tooltip = "Toggle custom field of view",
    flag = "Toggle_FOV",
    callback = function(state)
        toggleFOV(state)
    end
}):AddBind({
    text = "FOV Key",
    tooltip = "Hotkey to toggle FOV",
    mode = "toggle",
    bind = "None",
    callback = function(v)
        toggleFOV(v)
    end
})



-- Character Customization Section
local seccharacter = _G.PlayerTab:AddSection("Character Customization", 2)
seccharacter:AddSeparator({ text = "Character Effects" })

-- === OPTIMIZED CHARACTER CUSTOMIZER ===
local CharacterCustomizer = {
    -- State tracking
    state = {
        rainbowEnabled = false,
        customColorEnabled = false,
        materialEnabled = false,
        transparencyEnabled = false,
        glowEnabled = false,
        outlineEnabled = false
    },
    
    -- Settings
    settings = {
        customColor = Config.characterEffects.defaultCustomColor,
        rainbowSpeed = Config.characterEffects.rainbowSpeedDefault,
        selectedMaterial = Config.characterEffects.defaultMaterial,
        transparencyValue = Config.characterEffects.transparencyDefault,
        glowColor = Config.characterEffects.defaultGlowColor,
        glowIntensity = Config.characterEffects.glowIntensityDefault,
        outlineColor = Config.characterEffects.defaultOutlineColor,
        outlineThickness = Config.characterEffects.outlineThicknessDefault
    },
    
    -- Storage
    originalProperties = {},
    partsCache = {},
    lastCacheUpdate = 0,
    connections = {},
    isInitialized = false,
    lastRainbowUpdate = 0
}

-- Optimized part detection with caching
function CharacterCustomizer:GetAllParts()
    local now = tick()
    if now - self.lastCacheUpdate < Config.partsCacheInterval and next(self.partsCache) then
        return self.partsCache
    end
    
    self.partsCache = {}
    
    if not character or not character.Parent then
        return self.partsCache
    end
    
    -- Character body parts
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            table.insert(self.partsCache, part)
        end
    end
    
    -- Accessories
    for _, accessory in pairs(character:GetChildren()) do
        if accessory:IsA("Accessory") then
            local handle = accessory:FindFirstChild("Handle")
            if handle and handle:IsA("BasePart") then
                table.insert(self.partsCache, handle)
            end
        end
    end
    
    -- First person arms (if present)
    local camera = workspace.CurrentCamera
    if camera then
        local arms = camera:FindFirstChild("Arms")
        if arms then
            for _, part in pairs(arms:GetDescendants()) do
                if part:IsA("BasePart") then
                    table.insert(self.partsCache, part)
                end
            end
        end
    end
    
    self.lastCacheUpdate = now
    return self.partsCache
end

-- Store original properties
function CharacterCustomizer:StoreOriginalProperties()
    if self.isInitialized then return end
    
    local parts = self:GetAllParts()
    
    for _, part in pairs(parts) do
        if part and part.Parent then
            self.originalProperties[part] = {
                color = part.Color,
                material = part.Material,
                transparency = part.Transparency
            }
        end
    end
    
    -- Store face transparency
    local head = character:FindFirstChild("Head")
    if head then
        local face = head:FindFirstChild("face")
        if face then
            self.originalProperties[face] = {
                transparency = face.Transparency
            }
        end
    end
    
    self.isInitialized = true
end

-- Rainbow effect with throttling
function CharacterCustomizer:UpdateRainbow()
    local now = tick()
    if now - self.lastRainbowUpdate < Config.rainbowUpdateInterval then return end
    self.lastRainbowUpdate = now
    
    if not self.state.rainbowEnabled then return end
    
    local hue = (now * self.settings.rainbowSpeed) % 1
    local color = Color3.fromHSV(hue, 1, 1)
    
    local parts = self:GetAllParts()
    for _, part in pairs(parts) do
        if part and part.Parent then
            pcall(function()
                part.Color = color
            end)
        end
    end
end

-- Apply custom color
function CharacterCustomizer:ApplyCustomColor()
    local parts = self:GetAllParts()
    for _, part in pairs(parts) do
        if part and part.Parent then
            pcall(function()
                part.Color = self.settings.customColor
            end)
        end
    end
end

-- Apply material
function CharacterCustomizer:ApplyMaterial()
    local materialEnum = Enum.Material[self.settings.selectedMaterial]
    if not materialEnum then return end
    
    local parts = self:GetAllParts()
    for _, part in pairs(parts) do
        if part and part.Parent then
            pcall(function()
                part.Material = materialEnum
            end)
        end
    end
end

-- Apply transparency
function CharacterCustomizer:ApplyTransparency()
    local parts = self:GetAllParts()
    for _, part in pairs(parts) do
        if part and part.Parent then
            pcall(function()
                part.Transparency = self.settings.transparencyValue
            end)
        end
    end
    
    -- Handle face transparency
    local head = character:FindFirstChild("Head")
    if head then
        local face = head:FindFirstChild("face")
        if face then
            pcall(function()
                face.Transparency = self.settings.transparencyValue * 0.8
            end)
        end
    end
end

-- Apply glow effect
function CharacterCustomizer:ApplyGlow()
    local parts = self:GetAllParts()
    for _, part in pairs(parts) do
        if part and part.Parent then
            pcall(function()
                -- Remove existing glow
                local oldGlow = part:FindFirstChild("CustomGlow")
                if oldGlow then oldGlow:Destroy() end
                
                -- Add new glow
                local light = Instance.new("PointLight")
                light.Name = "CustomGlow"
                light.Color = self.settings.glowColor
                light.Brightness = self.settings.glowIntensity
                light.Range = Config.characterEffects.glowRange
                light.Parent = part
            end)
        end
    end
end

-- Apply outline effect
function CharacterCustomizer:ApplyOutline()
    local parts = self:GetAllParts()
    for _, part in pairs(parts) do
        if part and part.Parent then
            pcall(function()
                -- Remove existing outline
                local oldOutline = part:FindFirstChild("CustomOutline")
                if oldOutline then oldOutline:Destroy() end
                
                -- Add new outline
                local box = Instance.new("SelectionBox")
                box.Name = "CustomOutline"
                box.Adornee = part
                box.Color3 = self.settings.outlineColor
                box.LineThickness = self.settings.outlineThickness
                box.Transparency = Config.characterEffects.outlineTransparency
                box.Parent = part
            end)
        end
    end
end

-- Remove glow effects
function CharacterCustomizer:RemoveGlow()
    local parts = self:GetAllParts()
    for _, part in pairs(parts) do
        if part and part.Parent then
            pcall(function()
                local glow = part:FindFirstChild("CustomGlow")
                if glow then glow:Destroy() end
            end)
        end
    end
end

-- Remove outline effects
function CharacterCustomizer:RemoveOutline()
    local parts = self:GetAllParts()
    for _, part in pairs(parts) do
        if part and part.Parent then
            pcall(function()
                local outline = part:FindFirstChild("CustomOutline")
                if outline then outline:Destroy() end
            end)
        end
    end
end

-- Restore original properties
function CharacterCustomizer:RestoreColors()
    for part, props in pairs(self.originalProperties) do
        if part and part.Parent and props then
            if not self.state.rainbowEnabled and not self.state.customColorEnabled then
                pcall(function()
                    if props.color then
                        part.Color = props.color
                    end
                end)
            end
        end
    end
end

function CharacterCustomizer:RestoreMaterials()
    for part, props in pairs(self.originalProperties) do
        if part and part.Parent and props then
            pcall(function()
                if props.material then
                    part.Material = props.material
                end
            end)
        end
    end
end

function CharacterCustomizer:RestoreTransparency()
    for part, props in pairs(self.originalProperties) do
        if part and part.Parent and props then
            pcall(function()
                if props.transparency ~= nil then
                    part.Transparency = props.transparency
                else
                    part.Transparency = 0
                end
            end)
        end
    end
end

-- Toggle functions
function CharacterCustomizer:ToggleRainbow(state)
    self.state.rainbowEnabled = state
    
    if state then
        if not self.isInitialized then
            self:StoreOriginalProperties()
        end
        
        -- Disable custom color
        self.state.customColorEnabled = false
        
        -- Start rainbow effect
        self:CleanupConnections("rainbow")
        local conn = RunService.Heartbeat:Connect(function()
            self:UpdateRainbow()
        end)
        table.insert(self.connections, {connection = conn, type = "rainbow"})
    else
        self:CleanupConnections("rainbow")
        if not self.state.customColorEnabled then
            self:RestoreColors()
        end
    end
end

function CharacterCustomizer:ToggleCustomColor(state)
    self.state.customColorEnabled = state
    
    if state then
        if not self.isInitialized then
            self:StoreOriginalProperties()
        end
        
        -- Disable rainbow
        self.state.rainbowEnabled = false
        self:CleanupConnections("rainbow")
        
        self:ApplyCustomColor()
    else
        if not self.state.rainbowEnabled then
            self:RestoreColors()
        end
    end
end

function CharacterCustomizer:ToggleMaterial(state)
    self.state.materialEnabled = state
    
    if state then
        if not self.isInitialized then
            self:StoreOriginalProperties()
        end
        self:ApplyMaterial()
    else
        self:RestoreMaterials()
    end
end

function CharacterCustomizer:ToggleTransparency(state)
    self.state.transparencyEnabled = state
    
    if state then
        if not self.isInitialized then
            self:StoreOriginalProperties()
        end
        self:ApplyTransparency()
    else
        self:RestoreTransparency()
    end
end

function CharacterCustomizer:ToggleGlow(state)
    self.state.glowEnabled = state
    
    if state then
        if not self.isInitialized then
            self:StoreOriginalProperties()
        end
        self:ApplyGlow()
    else
        self:RemoveGlow()
    end
end

function CharacterCustomizer:ToggleOutline(state)
    self.state.outlineEnabled = state
    
    if state then
        if not self.isInitialized then
            self:StoreOriginalProperties()
        end
        self:ApplyOutline()
    else
        self:RemoveOutline()
    end
end

-- Connection management
function CharacterCustomizer:CleanupConnections(connectionType)
    for i = #self.connections, 1, -1 do
        local conn = self.connections[i]
        if type(conn) == "table" then
            if not connectionType or conn.type == connectionType then
                if conn.connection and conn.connection.Connected then
                    conn.connection:Disconnect()
                end
                table.remove(self.connections, i)
            end
        end
    end
end

-- Full restore function
function CharacterCustomizer:FullRestore()
    -- Disable all states
    for key in pairs(self.state) do
        self.state[key] = false
    end
    
    -- Clean up connections
    self:CleanupConnections()
    
    -- Remove effects
    self:RemoveGlow()
    self:RemoveOutline()
    
    -- Restore all properties
    for part, props in pairs(self.originalProperties) do
        if part and part.Parent and props then
            pcall(function()
                if props.color then
                    part.Color = props.color
                end
                if props.material then
                    part.Material = props.material
                end
                if props.transparency ~= nil then
                    part.Transparency = props.transparency
                else
                    part.Transparency = 0
                end
            end)
        end
    end
    
    -- Clear cache and reset
    self.partsCache = {}
    self.lastCacheUpdate = 0
    self.isInitialized = false
    self.originalProperties = {}
end

-- Character respawn handling
function CharacterCustomizer:HandleCharacterAdded(char)
    character = char
    humanoid = char:WaitForChild("Humanoid", 5)
    
    -- Reset everything
    self.partsCache = {}
    self.lastCacheUpdate = 0
    self.isInitialized = false
    self.originalProperties = {}
    
    -- Wait for character to fully load
    task.wait(1)
    
    -- Reapply active effects
    local activeEffects = {}
    for effect, enabled in pairs(self.state) do
        if enabled then
            activeEffects[effect] = true
        end
    end
    
    -- Store originals first
    if next(activeEffects) then
        self:StoreOriginalProperties()
        
        -- Reapply effects
        if activeEffects.rainbowEnabled then
            self:ToggleRainbow(true)
        elseif activeEffects.customColorEnabled then
            self:ApplyCustomColor()
        end
        
        if activeEffects.materialEnabled then
            self:ApplyMaterial()
        end
        
        if activeEffects.transparencyEnabled then
            self:ApplyTransparency()
        end
        
        if activeEffects.glowEnabled then
            self:ApplyGlow()
        end
        
        if activeEffects.outlineEnabled then
            self:ApplyOutline()
        end
    end
end

-- === UI ELEMENTS ===

-- Rainbow Section
seccharacter:AddToggle({
    text = "Rainbow Character",
    state = false,
    tooltip = "Makes your character cycle through rainbow colors",
    flag = "Toggle_Rainbow",
    callback = function(state)
        CharacterCustomizer:ToggleRainbow(state)
    end
}):AddBind({
    text = "Rainbow Key",
    tooltip = "Hotkey to toggle rainbow effect",
    mode = "toggle",
    bind = "None",
    callback = function(v)
        CharacterCustomizer:ToggleRainbow(v)
    end
})

seccharacter:AddSlider({
    text = "Rainbow Speed",
    tooltip = "Adjust the speed of the rainbow effect",
    flag = "rainbowspeed",
    min = Config.characterEffects.rainbowSpeedMin,
    max = Config.characterEffects.rainbowSpeedMax,
    increment = Config.characterEffects.rainbowSpeedIncrement,
    default = Config.characterEffects.rainbowSpeedDefault,
    callback = function(v)
        CharacterCustomizer.settings.rainbowSpeed = v
    end
})

seccharacter:AddSeparator({ text = "Color & Material" })

-- Custom Color Section
seccharacter:AddToggle({
    text = "Custom Color",
    state = false,
    tooltip = "Apply a custom color to your character",
    flag = "Toggle_CustomColor",
    callback = function(state)
        CharacterCustomizer:ToggleCustomColor(state)
    end
}):AddBind({
    text = "Color Key",
    tooltip = "Hotkey to toggle custom color",
    mode = "toggle",
    bind = "None",
    callback = function(v)
        CharacterCustomizer:ToggleCustomColor(v)
    end
})

seccharacter:AddColor({
    text = "Character Color",
    tooltip = "Choose a color for your character",
    color = CharacterCustomizer.settings.customColor,
    trans = 0,
    callback = function(color)
        CharacterCustomizer.settings.customColor = color
        if CharacterCustomizer.state.customColorEnabled then
            CharacterCustomizer:ApplyCustomColor()
        end
    end
})

-- Material Section
seccharacter:AddToggle({
    text = "Custom Material",
    state = false,
    tooltip = "Apply a custom material to your character",
    flag = "Toggle_Material",
    callback = function(state)
        CharacterCustomizer:ToggleMaterial(state)
    end
}):AddBind({
    text = "Material Key",
    tooltip = "Hotkey to toggle custom material",
    mode = "toggle",
    bind = "None",
    callback = function(v)
        CharacterCustomizer:ToggleMaterial(v)
    end
})

seccharacter:AddList({
    text = "Material Type",
    tooltip = "Select character material",
    selected = Config.characterEffects.defaultMaterial,
    multi = false,
    max = 10,
    values = Config.materials,
    callback = function(v)
        CharacterCustomizer.settings.selectedMaterial = v
        if CharacterCustomizer.state.materialEnabled then
            CharacterCustomizer:ApplyMaterial()
        end
    end
})

seccharacter:AddSeparator({ text = "Transparency & Effects" })

-- Transparency Section
seccharacter:AddToggle({
    text = "Character Transparency",
    state = false,
    tooltip = "Make your character transparent",
    flag = "Toggle_Transparency",
    callback = function(state)
        CharacterCustomizer:ToggleTransparency(state)
    end
}):AddBind({
    text = "Transparency Key",
    tooltip = "Hotkey to toggle transparency",
    mode = "toggle",
    bind = "None",
    callback = function(v)
        CharacterCustomizer:ToggleTransparency(v)
    end
})

seccharacter:AddSlider({
    text = "Transparency Level",
    tooltip = "Adjust character transparency",
    flag = "transparencylevel",
    min = Config.characterEffects.transparencyMin,
    max = Config.characterEffects.transparencyMax,
    increment = Config.characterEffects.transparencyIncrement,
    default = Config.characterEffects.transparencyDefault,
    callback = function(v)
        CharacterCustomizer.settings.transparencyValue = v
        if CharacterCustomizer.state.transparencyEnabled then
            CharacterCustomizer:ApplyTransparency()
        end
    end
})

-- Glow Section
seccharacter:AddToggle({
    text = "Character Glow",
    state = false,
    tooltip = "Add a glowing effect to your character",
    flag = "Toggle_Glow",
    callback = function(state)
        CharacterCustomizer:ToggleGlow(state)
    end
}):AddBind({
    text = "Glow Key",
    tooltip = "Hotkey to toggle glow effect",
    mode = "toggle",
    bind = "None",
    callback = function(v)
        CharacterCustomizer:ToggleGlow(v)
    end
})

seccharacter:AddColor({
    text = "Glow Color",
    tooltip = "Choose the glow color",
    color = CharacterCustomizer.settings.glowColor,
    trans = 0,
    callback = function(color)
        CharacterCustomizer.settings.glowColor = color
        if CharacterCustomizer.state.glowEnabled then
            CharacterCustomizer:ApplyGlow()
        end
    end
})

seccharacter:AddSlider({
    text = "Glow Intensity",
    tooltip = "Adjust glow brightness",
    flag = "glowintensity",
    min = Config.characterEffects.glowIntensityMin,
    max = Config.characterEffects.glowIntensityMax,
    increment = Config.characterEffects.glowIntensityIncrement,
    default = Config.characterEffects.glowIntensityDefault,
    callback = function(v)
        CharacterCustomizer.settings.glowIntensity = v
        if CharacterCustomizer.state.glowEnabled then
            CharacterCustomizer:ApplyGlow()
        end
    end
})

-- Outline Section
seccharacter:AddToggle({
    text = "Character Outline",
    state = false,
    tooltip = "Add an outline to your character",
    flag = "Toggle_Outline",
    callback = function(state)
        CharacterCustomizer:ToggleOutline(state)
    end
}):AddBind({
    text = "Outline Key",
    tooltip = "Hotkey to toggle outline",
    mode = "toggle",
    bind = "None",
    callback = function(v)
        CharacterCustomizer:ToggleOutline(v)
    end
})

seccharacter:AddColor({
    text = "Outline Color",
    tooltip = "Choose the outline color",
    color = CharacterCustomizer.settings.outlineColor,
    trans = 0,
    callback = function(color)
        CharacterCustomizer.settings.outlineColor = color
        if CharacterCustomizer.state.outlineEnabled then
            CharacterCustomizer:ApplyOutline()
        end
    end
})

seccharacter:AddSlider({
    text = "Outline Thickness",
    tooltip = "Adjust outline thickness",
    flag = "outlinethickness",
    min = Config.characterEffects.outlineThicknessMin,
    max = Config.characterEffects.outlineThicknessMax,
    increment = Config.characterEffects.outlineThicknessIncrement,
    default = Config.characterEffects.outlineThicknessDefault,
    callback = function(v)
        CharacterCustomizer.settings.outlineThickness = v
        if CharacterCustomizer.state.outlineEnabled then
            CharacterCustomizer:ApplyOutline()
        end
    end
})

-- Control Section
seccharacter:AddSeparator({ text = "Controls" })

seccharacter:AddButton({
    text = "Reset All Effects",
    tooltip = "Reset all character customization to original",
    callback = function()
        CharacterCustomizer:FullRestore()
        warn("All character effects have been reset")
    end
})

seccharacter:AddButton({
    text = "Refresh Character",
    tooltip = "Refresh character detection and reapply effects",
    callback = function()
        if character then
            CharacterCustomizer:HandleCharacterAdded(character)
            warn("Character refreshed and effects reapplied")
        else
            warn("No character found to refresh")
        end
    end
})

-- === EVENT CONNECTIONS ===

-- Connect to character events
player.CharacterAdded:Connect(function(char)
    CharacterCustomizer:HandleCharacterAdded(char)
end)

-- Monitor arms addition/removal
if workspace.Camera then
    workspace.Camera.ChildAdded:Connect(function(child)
        if child.Name == "Arms" then
            task.wait(0.1)
            CharacterCustomizer.partsCache = {}
            CharacterCustomizer.lastCacheUpdate = 0
            
            -- Reapply effects to arms
            if CharacterCustomizer.isInitialized then
                if CharacterCustomizer.state.rainbowEnabled then
                    -- Rainbow will handle automatically
                elseif CharacterCustomizer.state.customColorEnabled then
                    CharacterCustomizer:ApplyCustomColor()
                end
                
                if CharacterCustomizer.state.materialEnabled then
                    CharacterCustomizer:ApplyMaterial()
                end
                
                if CharacterCustomizer.state.transparencyEnabled then
                    CharacterCustomizer:ApplyTransparency()
                end
                
                if CharacterCustomizer.state.glowEnabled then
                    CharacterCustomizer:ApplyGlow()
                end
                
                if CharacterCustomizer.state.outlineEnabled then
                    CharacterCustomizer:ApplyOutline()
                end
            end
        end
    end)
end

-- Initialize for existing character
if character then
    task.spawn(function()
        CharacterCustomizer:HandleCharacterAdded(character)
    end)
end

-- Cleanup function for character effects
local function cleanupCharacterEffects()
    CharacterCustomizer:CleanupConnections()
    CharacterCustomizer:FullRestore()
end

-- Store cleanup function for external access
_G.PlayerTab.CleanupCharacterEffects = cleanupCharacterEffects
